
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Jianyu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="PengYuan">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Jianyu">
<meta property="og:url" content="https://pengyuanqiuqiu.github.io/index.html">
<meta property="og:site_name" content="Jianyu">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jianyu">

    
    <link rel="alternative" href="http://www.163.com/rss/" title="Jianyu" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Jianyu" title="Jianyu"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Jianyu">Jianyu</a></h1>
				<h2 class="blog-motto">Learn more and more</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:pengyuanqiuqiu.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/06/决策树算法/" title="决策树ID3/C4.5/CART算法比较" itemprop="url">决策树ID3/C4.5/CART算法比较</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-06T02:31:04.711Z" itemprop="datePublished"> 发表于 2018-07-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="决策树介绍"><a href="#决策树介绍" class="headerlink" title="决策树介绍"></a>决策树介绍</h3><p>​          决策树模型在监督学习中非常常见，可用于分类（二分类、多分类）和回归。虽然将多棵弱决策树的Bagging、Random Forest、Boosting等tree ensembel 模型更为常见，但是“完全生长”决策树因为其简单直观，具有很强的解释性，一般而言一棵“完全生长”的决策树包含，<strong>特征选择、决策树构建、剪枝</strong>三个过程。决策树是一种<strong>贪心算法</strong>，每次选取的分割数据的特征都是当前的最佳选择，并不关心是否达到最优。</p>
<h3 id="决策树的优缺点"><a href="#决策树的优缺点" class="headerlink" title="决策树的优缺点"></a>决策树的优缺点</h3><p>优点：</p>
<ol>
<li>决策树算法中学习简单的决策规则建立决策树模型的过程非常容易理解，</li>
<li>决策树模型可以可视化，非常直观</li>
<li>应用范围广，可用于分类和回归，而且非常容易做多类别的分类</li>
<li>能够处理数值型和连续的样本特征</li>
</ol>
<p>​    缺点：</p>
<ol>
<li>很容易在训练数据中生成复杂的树结构，造成过拟合（overfitting）。剪枝可以缓解过拟合的负作用，常用方法是限制树的高度、叶子节点中的最少样本数量。</li>
<li>学习一棵最优的决策树被认为是NP-Complete问题。实际中的决策树是基于启发式的贪心算法建立的，这种算法不能保证建立全局最优的决策树。Random Forest 引入随机能缓解这个问题</li>
</ol>
<h4 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h4><p>​        ID3决策树可以有多个分支，但是不能处理特征值为连续的情况。决策树是一种贪心算法，每次选取的分割数据的特征都是当前的最佳选择，并不关心是否达到最优。在ID3中，每次根据“最大信息熵增益”选取当前最佳的特征来分割数据，并按照该特征的所有取值来切分，也就是说如果一个特征有4种取值，数据将被切分4份，一旦按某特征切分后，该特征在之后的算法执行中，将不再起作用，所以有观点认为这种切分方式过于迅速。ID3算法十分简单，核心是根据“最大信息熵增益”原则选择划分当前数据集的最好特征，信息熵是信息论里面的概念，是信息的度量方式，不确定度越大或者说越混乱，熵就越大。在建立决策树的过程中，根据特征属性划分数据，使得原本“混乱”的数据的熵(混乱度)减少，按照不同特征划分数据熵减少的程度会不一样。在ID3中选择熵减少程度最大的特征来划分数据（贪心），也就是“最大信息熵增益”原则。</p>
<p>缺点：①切分过于迅速；</p>
<p>②不能直接处理特征值为连续的情况，只有事先将连续型特征转换成离散型，但这转换过程中会破坏连续型变量的内在性质;</p>
<p>③ </p>
<p><img src="http://120.25.221.136/images/dt/tree.png" alt=""></p>
<h4 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a><strong>C4.5算法</strong></h4><p>C4.5是Ross Quinlan在1993年在ID3的基础上改进而提出的。.ID3采用的信息增益度量存在一个缺点，它一般会优先选择有较多属性值的Feature,因为属性值多的Feature会有相对较大的信息增益?(信息增益反映的给定一个条件以后不确定性减少的程度,必然是分得越细的数据集确定性更高,也就是条件熵越小,信息增益越大).为了避免这个不足C4.5中是用信息增益比率(gain ratio)来作为选择分支的准则。信息增益比率通过引入一个被称作分裂信息(Split information)的项来惩罚取值较多的Feature。除此之外，C4.5还弥补了ID3中不能处理特征属性值连续的问题。<strong>信息增益比本质： 是在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。一般为原集合信息熵。</strong></p>
<p><img src="http://120.25.221.136/images/dt/tree2.png" alt=""></p>
<h3 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a><strong>CART算法</strong></h3><p>CART（Classification and Regression tree）分类回归树由L.Breiman,J.Friedman,R.Olshen和C.Stone于1984年提出。ID3中根据属性值分割数据，之后该特征不会再起作用，这种快速切割的方式会影响算法的准确率。CART是一棵二叉树，采用二元切分法，每次把数据切成两份，分别进入左子树、右子树。而且每个非叶子节点都有两个孩子，所以CART的叶子节点比非叶子多1。相比ID3和C4.5，CART应用要多一些，既可以用于分类也可以用于回归。CART分类时，使用基尼指数（Gini）来选择最好的数据分割的特征，gini描述的是纯度，与信息熵的含义相似。CART中每一次迭代都会降低GINI系数。下图显示信息熵增益的一半，Gini指数，分类误差率三种评价指标非常接近。回归时使用均方差作为loss function。基尼系数的计算与信息熵增益的方式非常类似，公式如下：</p>
<p><img src="http://120.25.221.136/images/dt/tree3.png" alt=""></p>
<p><strong>三种方法对比：</strong></p>
<p><strong>ID3的缺点，倾向于选择水平数量较多的变量，可能导致训练得到一个庞大且深度浅的树；另外输入变量必须是分类变量（连续变量必须离散化）；最后无法处理空值。</strong></p>
<p><strong>C4.5选择了信息增益率替代信息增益。</strong></p>
<p><strong>CART以基尼系数替代熵；最小化不纯度而不是最大化信息增益。</strong></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/05/掌握Adaboost算法/" title="掌握Addaboost算法" itemprop="url">掌握Addaboost算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-05T09:13:00.522Z" itemprop="datePublished"> 发表于 2018-07-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="Adaboost介绍"><a href="#Adaboost介绍" class="headerlink" title="Adaboost介绍"></a>Adaboost介绍</h3><p>AdaBoost，是英文”Adaptive Boosting”（自适应增强）的缩写，由Yoav Freund和Robert Schapire在1995年提出。它的自适应在于：前一个基本分类器分错的样本会得到加强，加权后的全体样本再次被用来训练下一个基本分类器。同时，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数。</p>
<h3 id="Adaboost算法步骤"><a href="#Adaboost算法步骤" class="headerlink" title="Adaboost算法步骤"></a>Adaboost算法步骤</h3><p>具体说来，整个Adaboost 迭代算法就3步：</p>
<ol>
<li>初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1/N。</li>
<li>训练弱分类器。具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</li>
<li>将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。</li>
</ol>
<p>AdaBoost算法过程</p>
<p>​    给定训练数据集：<img src="http://120.25.221.136/images/adsboost/ada.jpg" alt="">，其中用于表示训练样本的类别标签<img src="http://120.25.221.136/images/adsboost/yi.jpg" alt="">，i=1,…,N。Adaboost的目的就是从训练数据中学习一系列弱分类器或基本分类器，然后将这些弱分类器组合成一个强分类器。</p>
<p>相关符号定义：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost2.jpg" alt=""></p>
<p>Adaboost的算法流程如下：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost4.jpg" alt=""></p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost5.jpg" alt=""></p>
<p>相关说明：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost7.jpg" alt=""></p>
<p>综合上面的推导，可得样本分错与分对时，其权值更新的公式为：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost8.jpg" alt=""></p>
<h3 id="AdaBoost实例讲解"><a href="#AdaBoost实例讲解" class="headerlink" title="AdaBoost实例讲解"></a>AdaBoost实例讲解</h3><p>例：给定如图所示的训练样本，弱分类器采用平行于坐标轴的直线，用Adaboost算法的实现强分类过程。</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost9.jpg" alt=""></p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost11.jpg" alt=""></p>
<p>数据分析：</p>
<p>   将这10个样本作为训练数据，根据X和Y的对应关系，可把这10个数据分为两类，图中用“+”表示类别1，用“O”表示类别-1。本例使用水平或者垂直的直线作为分类器，图中已经给出了三个弱分类器，即：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost12.jpg" alt=""></p>
<p>初始化：</p>
<p>   首先需要初始化训练样本数据的权值分布，每一个训练样本最开始时都被赋予相同的权值：wi=1/N，这样训练样本集的初始权值分布D1(i)：</p>
<p>   令每个权值w1i= 1/N = 0.1，其中，N = 10，i = 1,2, …, 10，然后分别对于t= 1,2,3, …等值进行迭代（t表示迭代次数，表示第t轮），下表已经给出训练样本的权值分布情况：</p>
<p><img src="http://120.25.221.136/images/adsboost/ada10.jpg" alt=""></p>
<p>第1次迭代t=1：</p>
<p>初试的权值分布D1为1/N（10个数据，每个数据的权值皆初始化为0.1），</p>
<p>D1=[0.1,  0.1, 0.1, 0.1, 0.1, 0.1,0.1, 0.1, 0.1, 0.1]</p>
<p>  在权值分布D1的情况下，取已知的三个弱分类器h1、h2和h3中误差率最小的分类器作为第1个基本分类器H1(x)（三个弱分类器的误差率都是0.3，那就取第1个吧）</p>
<p><img src="http://120.25.221.136/images/adsboost/ada11.jpg" alt=""></p>
<p>  在分类器H1(x)=h1情况下，样本点“5 7 8”被错分，因此基本分类器H1(x)的误差率为：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost13.jpg" alt=""></p>
<p>  可见，被误分类样本的权值之和影响误差率e，误差率e影响基本分类器在最终分类器中所占的权重α。</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost14.jpg" alt=""></p>
<p>  然后，更新训练样本数据的权值分布，用于下一轮迭代，对于正确分类的训练样本“1 2 3 4 6 9 10”（共7个）的权值更新为：<img src="http://120.25.221.136/images/adsboost/adaboost15.jpg" alt=""></p>
<p>  这样，第1轮迭代后，最后得到各个样本数据新的权值分布：</p>
<p>D2=[1/14,1/14,1/14,1/14,1/6,1/14,1/6,1/6,1/14,1/14]</p>
<p>由于样本数据“5 7 8”被H1(x)分错了，所以它们的权值由之前的0.1增大到1/6；反之，其它数据皆被分正确，所以它们的权值皆由之前的0.1减小到1/14，下表给出了权值分布的变换情况：</p>
<p>​    可得分类函数：f1(x)= α1H1(x) = 0.4236H1(x)。此时，组合一个基本分类器sign(f1(x))作为强分类器在训练数据集上有3个误分类点（即5 7 8），此时强分类器的训练错误为：0.3</p>
<p>第二次迭代t=2：</p>
<p>  在权值分布D2的情况下，再取三个弱分类器h1、h2和h3中误差率最小的分类器作为第2个基本分类器H2(x)：①　当取弱分类器h1=X1=2.5时，此时被错分的样本点为“5 7 8”：误差率e=1/6+1/6+1/6=3/6=1/2；</p>
<p>②　当取弱分类器h2=X1=8.5时，此时被错分的样本点为“3 4 6”：误差率e=1/14+1/14+1/14=3/14；③　当取弱分类器h3=X2=6.5时，此时被错分的样本点为“1 2 9”：误差率e=1/14+1/14+1/14=3/14；   因此，取当前最小的分类器h2作为第2个基本分类器H2(x)：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost17.jpg" alt=""></p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost18.jpg" alt=""></p>
<p>​    显然，H2(x)把样本“3 4 6”分错了，根据D2可知它们的权值为D2(3)=1/14，D2(4)=1/14， D2(6)=1/14，所以H2(x)在训练数据集上的误差率：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost19.jpg" alt=""></p>
<p>  这样，第2轮迭代后，最后得到各个样本数据新的权值分布：</p>
<p>D3=[1/22,1/22,1/6,1/6,7/66,1/6,7/66,7/66,1/22,1/22]</p>
<p>  下表给出了权值分布的变换情况：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost20.jpg" alt=""></p>
<p>   可得分类函数：f2(x)=0.4236H1(x) + 0.6496H2(x)。此时，组合两个基本分类器sign(f2(x))作为强分类器在训练数据集上有3个误分类点（即3 4 6），此时强分类器的训练错误为：0.3</p>
<p>第三次迭代t=3:</p>
<p>  在权值分布D3的情况下，再取三个弱分类器h1、h2和h3中误差率最小的分类器作为第3个基本分类器H3(x)：①　当取弱分类器h1=X1=2.5时，此时被错分的样本点为“5 7 8”：误差率e=7/66+7/66+7/66=7/22；</p>
<p>②　当取弱分类器h2=X1=8.5时，此时被错分的样本点为“3 4 6”：误差率e=1/6+1/6+1/6=1/2=0.5；</p>
<p>③　当取弱分类器h3=X2=6.5时，此时被错分的样本点为“1 2 9”：误差率e=1/22+1/22+1/22=3/22；</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost21.jpg" alt=""></p>
<p>   因此，取当前最小的分类器h3作为第3个基本分类器H3(x)：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost22.jpg" alt=""></p>
<p>  这样，第3轮迭代后，得到各个样本数据新的权值分布为：</p>
<p>D4=[1/6,1/6,11/114,11/114,7/114,11/114,7/114,7/114,1/6,1/38]</p>
<p>  下表给出了权值分布的变换情况：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost23.jpg" alt=""></p>
<p>​    可得分类函数：f3(x)=0.4236H1(x) + 0.6496H2(x)+0.9229H3(x)。此时，组合三个基本分类器sign(f3(x))作为强分类器，在训练数据集上有0个误分类点。至此，整个训练过程结束。</p>
<p>  整合所有分类器，可得最终的强分类器为：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost24.jpg" alt=""></p>
<p><strong>这个强分类器Hfinal对训练样本的错误率为0！</strong></p>
<h3 id="AdaBoost的优点和缺点"><a href="#AdaBoost的优点和缺点" class="headerlink" title="AdaBoost的优点和缺点"></a>AdaBoost的优点和缺点</h3><p><strong>优点</strong></p>
<p>​     （1）Adaboost提供一种框架，在框架内可以使用各种方法构建子分类器。可以使用简单的弱分类器，不用对特征进行筛选，也<strong>不存在过拟合的现象</strong>。<strong>(低偏差低方差)</strong></p>
<p>​     （2）Adaboost算法不需要弱分类器的先验知识，最后得到的强分类器的分类精度依赖于所有弱分类器。无论是应用于人造数据还是真实数据，Adaboost都能显著的提高学习精度。</p>
<p>​     （3）Adaboost算法不需要预先知道弱分类器的错误率上限，且最后得到的强分类器的分类精度依赖于所有弱分类器的分类精度，可以深挖分类器的能力。Adaboost可以根据弱分类器的反馈，自适应地调整假定的错误率，执行的效率高。</p>
<p>​     （4）Adaboost对同一个训练样本集训练不同的弱分类器，按照一定的方法把这些弱分类器集合起来，构造一个分类能力很强的强分类器，即“三个臭皮匠赛过一个诸葛亮”。</p>
<p><strong>缺点：</strong></p>
<p>​     在Adaboost训练过程中，Adaboost会使得难于分类样本的权值呈指数增长，训练将会过于偏向这类困难的样本，导致Adaboost算法易受噪声干扰。此外，Adaboost依赖于弱分类器，而弱分类器的训练时间往往很长。</p>
<p><strong>为什么AdaBoost不会过拟合？</strong></p>
<p>　　关于Adaboost，它是boosting算法，从bias-variance（偏差-方差）的角度来看，boosting算法主要关注的是降低偏差</p>
<p>　　而boosting算法每个分类器都是弱分类器，而弱分类器的特性就是high-bias &amp; low variance（高偏差-低方差），其与生俱来的优点就是泛化性能好</p>
<p>　　因此，将多个算法组合起来之后，可以达到降偏差的效果，进而得到一个偏差小、方差小的泛化能力好的模型。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/04/HIVE自定义函数之UDF，UDAF和UDTF区别/" title="HIVE自定义函数之UDF，UDAF和UDTF区别" itemprop="url">HIVE自定义函数之UDF，UDAF和UDTF区别</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-04T12:50:58.035Z" itemprop="datePublished"> 发表于 2018-07-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p> <strong>(1)udf(user defined function)：  自定义函数，特点是输入一行，输出一行</strong></p>
<p>  <strong>(2)udaf(user defined aggregation function)：自定义聚合函数，特点是输入多行，输出一行</strong></p>
<p>  <strong>(3)udtf(User-Defined Table-Generating Functions):自定义拆分函数，特点是输入一行，输出多行</strong></p>
<p>2、使用</p>
<p>​    (1)UDF开发和使用步骤</p>
<p>​       创建函数流程<br>a、自定义一个Java类<br>b、继承UDF类<br>c、重写evaluate方法<br>d、打成jar包<br>e、在hive执行add jar方法 (临时使用)<br>f、在hive执行创建模板函数<br>g、hql中使用</p>
<p>   (2)UDAF开发和使用步骤   </p>
<p>​           a、顶层UDAF类继承<br>            org.apache.hadoop.hive.ql.udf.generic.GenericUDAFEvaluator里面编写嵌套类evaluator实现UDAF的逻辑。</p>
<p>​           b、实现resolver :resolver负责类型检查，操作符重载<br>                 resolver通常继承<br>                 org.apache.hadoop.hive.ql.udf.GenericUDAFResolver2，但是更建议继承AbstractGenericUDAFResolver，</p>
<p>​                  隔离将来hive接口的变化。<br>                 GenericUDAFResolver和GenericUDAFResolver2接口的区别是后面的允许evaluator实现可以访问更多的信息，</p>
<p>​                 例如DISTINCT限定符，通配符FUNCTION(*)。</p>
<p>​           c、实现evaluator :evaluator真正实现UDAF的逻辑<br>                 所有evaluators必须继承抽象类<br>                 org.apache.hadoop.hive.ql.udf.generic.GenericUDAFEvaluator。予类必须实现它的一些抽象方法，</p>
<p>​                 实现UDAF的逻辑。</p>
<p>​           d、打成jar包<br>   e、在hive执行add jar方法 (临时使用)<br>   f、在hive执行创建模板函数<br>   g、hql中使用</p>
<p>​       (3)UDTF开发和使用</p>
<p>​         a、 继承org.apache.hadoop.hive.ql.udf.generic.GenericUDTF,实现initialize, process, close三个方法。</p>
<p>  b、UDTF首先会调用initialize方法，此方法返回UDTF的返回行的信息（返回个数，类型）。</p>
<p>  c、初始化完成后，会调用process方法,真正的处理过程在process函数中，在process中，每一次forward()调用产生一行；</p>
<p>​       如果产生多列可以将多个列的值放在一个数组中，然后将该数组传入到forward()函数。</p>
<p>​      最后close()方法调用，对需要清理的方法进行清理。</p>
<p>  d、打成jar包 </p>
<p>  e、在hive执行add jar方法 (临时使用)</p>
<p>  f、在hive执行创建模板函数 </p>
<p>  g、hql中使用</p>
<p>​     注意：UDTF有两种使用方法，一种直接放到select后面，一种和lateral view一起使用。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/04/hive 复合结构Map、Struct/" title="hive 复合结构Map、Struct(转)" itemprop="url">hive 复合结构Map、Struct(转)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-04T07:37:08.038Z" itemprop="datePublished"> 发表于 2018-07-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Map详解</p>
<p>hive里支持map的结构如下：</p>
<p>(key1, value1, key2, value2, …) Creates a map with the given key/value pairs</p>
<p>建表语句：</p>
<p>create table test_map(name string, score map<string,int>)</string,int></p>
<p>ROW FORMAT DELIMITED</p>
<p>FIELDS TERMINATED BY ‘\t’</p>
<p>COLLECTION ITEMS TERMINATED BY ‘,’</p>
<p>MAP KEYS TERMINATED BY ‘:’</p>
<p>测试数据</p>
<p>cat test</p>
<p>leilei 数学:99,语文:90,英语:96</p>
<p>lucy 数学:100,语文:85,英语:91</p>
<p>将数据导入表中：</p>
<p>LOAD DATA LOCAL INPATH ‘/home/webopa/lei.wang/datas_test/test_map’ OVERWRITE INTO TABLE test_map;</p>
<p>在表中查询：</p>
<p>hive&gt; select * from test_map;</p>
<p>OK</p>
<p>leilei {“数学”:99,”语文”:90,”英语”:96}</p>
<p>lucy {“数学”:100,”语文”:85,”英语”:91}</p>
<p>Time taken: 0.052 seconds, Fetched: 2 row(s)</p>
<p>hive&gt; select ts.name,ts.score[‘数学’] from test_map ts;</p>
<p>Total jobs = 1</p>
<p>Launching Job 1 out of 1</p>
<p>…</p>
<p>Total MapReduce CPU Time Spent: 3 seconds 280 msec</p>
<p>OK</p>
<p>leilei 99</p>
<p>lucy 100</p>
<p>Time taken: 26.072 seconds, Fetched: 2 row(s)</p>
<p>Struct</p>
<p>hive里支持的Struct结构：</p>
<p>(val1, val2, val3, …) Creates a struct with the given field values. Struct field names will be col1, col2, …</p>
<p>建表语句</p>
<p>CREATE TABLE test_struct(name string,lable struct<price:string,pay:string,num:int>)</price:string,pay:string,num:int></p>
<p>ROW FORMAT DELIMITED</p>
<p>FIELDS TERMINATED BY ‘\t’</p>
<p>COLLECTION ITEMS TERMINATED BY ‘,’</p>
<p>测试数据</p>
<p>cat test_struct</p>
<p>aaa cheap,imm,1</p>
<p>bbb high,imm,2</p>
<p>将数据导入表中</p>
<p>LOAD DATA LOCAL INPATH ‘/home/webopa/lei.wang/datas_test/test_struct’ OVERWRITE INTO TABLE test_struct</p>
<p>在表中查询</p>
<p>hive&gt; select * from test_struct;</p>
<p>OK</p>
<p>aaa {“price”:”cheap”,”pay”:”imm”,”num”:1}</p>
<p>bbb {“price”:”high”,”pay”:”imm”,”num”:2}</p>
<p>Time taken: 0.046 seconds, Fetched: 2 row(s)</p>
<p>hive&gt; select name,lable.price from test_struct;</p>
<p>Total jobs = 1</p>
<p>Launching Job 1 out of 1</p>
<p>…</p>
<p>Total MapReduce CPU Time Spent: 1 seconds 270 msec</p>
<p>OK</p>
<p>aaa cheap</p>
<p>bbb high</p>
<p>Time taken: 20.054 seconds, Fetched: 2 row(s)</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/03/处理数据中的缺失值/" title="处理数据中的缺失值" itemprop="url">处理数据中的缺失值</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-03T02:12:53.412Z" itemprop="datePublished"> 发表于 2018-07-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="缺失值产生的原因"><a href="#缺失值产生的原因" class="headerlink" title="缺失值产生的原因"></a>缺失值产生的原因</h3><p>缺失值的产生的原因多种多样，主要分为机械原因和人为原因。</p>
<ul>
<li>机械原因是由于机械原因导致的数据收集或保存的失败造成的数据缺失，比如数据存储的失败，存储器损坏，机械故障导致某段时间数据未能收集（对于定时数据采集而言）。</li>
<li>人为原因是由于人的主观失误、历史局限或有意隐瞒造成的数据缺失，比如，在市场调查中被访人拒绝透露相关问题的答案，或者回答的问题是无效的，数据录入人员失误漏录了数据。 </li>
</ul>
<h3 id="处理缺失值的方法"><a href="#处理缺失值的方法" class="headerlink" title="处理缺失值的方法"></a>处理缺失值的方法</h3><p><strong>使用可用特征的均值来填补缺失值；</strong><br><strong> 使用特殊值来填补缺失值，如-1；</strong><br><strong> 忽略有缺失值的样本；</strong><br><strong> 使用相似样本的均值添补缺失值；</strong><br><strong> 使用另外的机器学习算法预测缺失值。</strong></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/21/sql面试题集锦/" title="SQL面试题集锦" itemprop="url">SQL面试题集锦</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-21T12:32:58.331Z" itemprop="datePublished"> 发表于 2018-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="1-有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。"><a href="#1-有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。" class="headerlink" title="1.有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。"></a>1.有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。</h4><p>A 学生表(student)<br>字段1 学生号(sid)<br>字段2 学生名(sname)</p>
<p>B 科目表(course)<br>字段1 科目号(cid)<br>字段2 科目名(cname)</p>
<p>C 成绩表(grade)<br>字段1 成绩号(gid)<br>字段2 学生号(sid)<br>字段3 科目号(cid)<br>字段4 成绩(score)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line"><span class="string">`sid`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`sname`</span>  <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`sid`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci</span><br><span class="line">ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cname ,t.sid <span class="keyword">from</span> grade <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span>  (<span class="keyword">SELECT</span> * <span class="keyword">from</span>  student ,course)<span class="keyword">as</span> t <span class="keyword">on</span> grade.cid=t.cid <span class="keyword">and</span> grade.sid=t.sid <span class="keyword">where</span> grade.score <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h4 id="2-有如下表："><a href="#2-有如下表：" class="headerlink" title="2.有如下表："></a>2.有如下表：</h4><table>
<thead>
<tr>
<th>日期(time)</th>
<th>结果(result)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2005-05-09</td>
<td>胜</td>
</tr>
<tr>
<td>2005-05-09</td>
<td>胜</td>
</tr>
<tr>
<td>2005-05-09</td>
<td>负</td>
</tr>
<tr>
<td>2005-05-09</td>
<td>负</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>胜</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>负</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>负</td>
</tr>
</tbody>
</table>
<p>如果要生成下列结果，该如何写sql语句？</p>
<table>
<thead>
<tr>
<th>日期</th>
<th>胜</th>
<th>负</th>
</tr>
</thead>
<tbody>
<tr>
<td>2005-05-09</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`game`</span> (</span><br><span class="line"><span class="string">`time`</span>  <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`result`</span>  <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci</span><br><span class="line">ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">time</span> ,<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">result</span> <span class="keyword">when</span> <span class="string">'胜'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">end</span> ) <span class="keyword">as</span> 胜,<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">result</span> <span class="keyword">when</span> <span class="string">'负'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">end</span> ) <span class="keyword">as</span> 负 <span class="keyword">from</span> game <span class="keyword">GROUP</span> <span class="keyword">BY</span> game.time</span><br></pre></td></tr></table></figure>
<h4 id="3-原表："><a href="#3-原表：" class="headerlink" title="3.原表："></a>3.原表：</h4><table>
<thead>
<tr>
<th style="text-align:center">gid</th>
<th style="text-align:center">sid</th>
<th style="text-align:center">cid</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">60</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">99</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">57</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">78</td>
</tr>
</tbody>
</table>
<p>为了方便阅读，查询此表后的显示结果如下（及格分数为60分）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">gid</th>
<th style="text-align:center">sid</th>
<th style="text-align:center">cid</th>
<th style="text-align:center">score</th>
<th style="text-align:center">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">60</td>
<td style="text-align:center">pass</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">90</td>
<td style="text-align:center">pass</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">99</td>
<td style="text-align:center">pass</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">57</td>
<td style="text-align:center">failed</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">58</td>
<td style="text-align:center">failed</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`garde`</span> (</span><br><span class="line"><span class="string">`gid`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`sid`</span>  <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`cid`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`score`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`gid`</span>))</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci</span><br><span class="line">ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,</span><br><span class="line"> <span class="keyword">case</span>  <span class="keyword">when</span> score &gt;<span class="string">'60'</span> <span class="keyword">then</span> <span class="string">'pass'</span> <span class="keyword">ELSE</span> <span class="string">"failed"</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> <span class="string">"mark"</span></span><br><span class="line"><span class="keyword">from</span> grade</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>,gid <span class="keyword">from</span>  grade  <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span>  <span class="keyword">HAVING</span>  <span class="keyword">count</span>(<span class="keyword">sid</span>)=(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">from</span> course)</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/19/交叉验证的原因/" title="交叉验证" itemprop="url">交叉验证</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-19T12:32:46.224Z" itemprop="datePublished"> 发表于 2018-06-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>训练过程中模型在训练集表现的很好，但在训练数据外的话对数据的拟合程度并不高，造成过拟合现象。素银使用交叉验证评估模型的预测能力，在一定的程度上减少过拟合，拥有更好的泛化能力。</li>
<li>在有限的数据中尽可能的获取更多的有效信息。</li>
</ul>
<h3 id="交叉验证的思想"><a href="#交叉验证的思想" class="headerlink" title="交叉验证的思想"></a>交叉验证的思想</h3><p>将原始数据进行分组，一部分作为训练集一部分作为测试集，首先用训练集对模型进行训练,再利用验证集来测试模型的泛化误差。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>留出法</p>
<p>在机器学习任务中，拿到数据后，我们首先会将原始数据集分为三部分：<strong>训练集、验证集和测试集</strong>。<br>训练集用于训练模型，验证集用于模型的参数选择配置，测试集对于模型来说是未知数据，用于评估模型的泛化能力。</p>
</li>
</ul>
<ul>
<li>k 折交叉验证（k-fold cross validation）</li>
</ul>
<p>​        k 折交叉验证通过对 k 个不同分组训练的结果进行平均来减少方差，因此模型的性能对数据的划分就不那么敏感。</p>
<ul>
<li>第一步，不重复抽样将原始数据随机分为 k 份。</li>
<li>第二步，每一次挑选其中 1 份作为测试集，剩余 k-1 份作为训练集用于模型训练。</li>
<li>第三步，重复第二步 k 次，这样每个子集都有一次机会作为测试集，其余机会作为训练集。</li>
<li>在每个训练集上训练后得到一个模型，</li>
<li>用这个模型在相应的测试集上测试，计算并保存模型的评估指标，</li>
<li>第四步，计算 k 组测试结果的平均值作为模型精度的估计，并作为当前 k 折交叉验证下模型的性能指标。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/19/MapReduce详解Shuffle(copy,sort,merge)过程/" title="MapReduce:详解Shuffle(copy,sort,merge)过程(转)" itemprop="url">MapReduce:详解Shuffle(copy,sort,merge)过程(转)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-19T11:23:28.266Z" itemprop="datePublished"> 发表于 2018-06-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Shuffle过程是MapReduce的核心，也被称为奇迹发生的地方。要想理解MapReduce， Shuffle是必须要了解的。我看过很多相关的资料，但每次看完都云里雾里的绕着，很难理清大致的逻辑，反而越搅越混。前段时间在做MapReduce job 性能调优的工作，需要深入代码研究MapReduce的运行机制，这才对Shuffle探了个究竟。考虑到之前我在看相关资料而看不懂时很恼火，所以在这里我尽最大的可能试着把Shuffle说清楚，让每一位想了解它原理的朋友都能有所收获。如果你对这篇文章有任何疑问或建议请留言到后面，谢谢！ </p>
<p>​        Shuffle的正常意思是洗牌或弄乱，可能大家更熟悉的是Java API里的Collections.shuffle(List)方法，它会随机地打乱参数list里的元素顺序。如果你不知道MapReduce里Shuffle是什么，那么请看这张图：</p>
<p><img src="http://dl.iteye.com/upload/attachment/456531/4df193f5-e56e-308f-9689-eac035dd8a2b.png" alt="img"></p>
<p>这张是官方对Shuffle过程的描述。但我可以肯定的是，单从这张图你基本不可能明白Shuffle的过程，因为它与事实相差挺多，细节也是错乱的。后面我会具体描述Shuffle的事实情况，所以这里你只要清楚Shuffle的大致范围就成－怎样把map task的输出结果有效地传送到reduce端。也可以这样理解， Shuffle描述着数据从map task输出到reduce task输入的这段过程。 </p>
<p>​        在Hadoop这样的集群环境中，大部分map task与reduce task的执行是在不同的节点上。当然很多情况下Reduce执行时需要跨节点去拉取其它节点上的map task结果。如果集群正在运行的job有很多，那么task的正常执行对集群内部的网络资源消耗会很严重。这种网络消耗是正常的，我们不能限制，能做的就是最大化地减少不必要的消耗。还有在节点内，相比于内存，磁盘IO对job完成时间的影响也是可观的。从最基本的要求来说，我们对Shuffle过程的期望可以有： </p>
<ul>
<li>完整地从map task端拉取数据到reduce 端。</li>
<li>在跨节点拉取数据时，尽可能地减少对带宽的不必要消耗。</li>
<li>减少磁盘IO对task执行的影响。</li>
</ul>
<p>​        OK，看到这里时，大家可以先停下来想想，如果是自己来设计这段Shuffle过程，那么你的设计目标是什么。我想能优化的地方主要在于减少拉取数据的量及尽量使用内存而不是磁盘。 </p>
<p>​        我的分析是基于Hadoop0.21.0的源码，如果与你所认识的Shuffle过程有差别，不吝指出。我会以WordCount为例，并假设它有8个map task和3个reduce task。从上图看出，Shuffle过程横跨map与reduce两端，所以下面我也会分两部分来展开。 </p>
<p>​        先看看map端的情况，如下图：</p>
<p><img src="http://dl.iteye.com/upload/attachment/456529/641c4f01-6c9d-322c-b428-9981866d86a6.jpg" alt="img"></p>
<p>​        上图可能是某个map task的运行情况。拿它与官方图的左半边比较，会发现很多不一致。官方图没有清楚地说明partition， sort与combiner到底作用在哪个阶段。我画了这张图，希望让大家清晰地了解从map数据输入到map端所有数据准备好的全过程。 </p>
<p>​        整个流程我分了四步。简单些可以这样说，每个map task都有一个内存缓冲区，存储着map的输出结果，当缓冲区快满的时候需要将缓冲区的数据以一个临时文件的方式存放到磁盘，当整个map task结束后再对磁盘中这个map task产生的所有临时文件做合并，生成最终的正式输出文件，然后等待reduce task来拉数据。 </p>
<p>​        当然这里的每一步都可能包含着多个步骤与细节，下面我对细节来一一说明： </p>
<ol>
<li><p>在map task执行时，它的输入数据来源于HDFS的block，当然在MapReduce概念中，map task只读取split。Split与block的对应关系可能是多对一，默认是一对一。在WordCount例子里，假设map的输入数据都是像“aaa”这样的字符串。 </p>
</li>
<li><p>在经过mapper的运行后，我们得知mapper的输出是这样一个key/value对： key是“aaa”， value是数值1。因为当前map端只做加1的操作，在reduce task里才去合并结果集。前面我们知道这个job有3个reduce task，到底当前的“aaa”应该交由哪个reduce去做呢，是需要现在决定的。 </p>
</li>
</ol>
<p>​        MapReduce提供Partitioner接口，它的作用就是根据key或value及reduce的数量来决定当前的这对输出数据最终应该交由哪个reduce task处理。默认对key hash后再以reduce task数量取模。默认的取模方式只是为了平均reduce的处理能力，如果用户自己对Partitioner有需求，可以订制并设置到job上。 </p>
<p>​        在我们的例子中，“aaa”经过Partitioner后返回0，也就是这对值应当交由第一个reducer来处理。接下来，需要将数据写入内存缓冲区中，缓冲区的作用是批量收集map结果，减少磁盘IO的影响。我们的key/value对以及Partition的结果都会被写入缓冲区。当然写入之前，key与value值都会被序列化成字节数组。 </p>
<p>​        整个内存缓冲区就是一个字节数组，它的字节索引及key/value存储结构我没有研究过。如果有朋友对它有研究，那么请大致描述下它的细节吧。 </p>
<ol>
<li>这个内存缓冲区是有大小限制的，默认是100MB。当map task的输出结果很多时，就可能会撑爆内存，所以需要在一定条件下将缓冲区中的数据临时写入磁盘，然后重新利用这块缓冲区。这个从内存往磁盘写数据的过程被称为Spill，中文可译为溢写，字面意思很直观。这个溢写是由单独线程来完成，不影响往缓冲区写map结果的线程。溢写线程启动时不应该阻止map的结果输出，所以整个缓冲区有个溢写的比例spill.percent。这个比例默认是0.8，也就是当缓冲区的数据已经达到阈值（buffer size <em> spill percent = 100MB </em> 0.8 = 80MB），溢写线程启动，锁定这80MB的内存，执行溢写过程。Map task的输出结果还可以往剩下的20MB内存中写，互不影响。 </li>
</ol>
<p>​        当溢写线程启动后，需要对这80MB空间内的key做排序(Sort)。排序是MapReduce模型默认的行为，这里的排序也是对序列化的字节做的排序。 </p>
<p>​        在这里我们可以想想，因为map task的输出是需要发送到不同的reduce端去，而内存缓冲区没有对将发送到相同reduce端的数据做合并，那么这种合并应该是体现是磁盘文件中的。从官方图上也可以看到写到磁盘中的溢写文件是对不同的reduce端的数值做过合并。所以溢写过程一个很重要的细节在于，如果有很多个key/value对需要发送到某个reduce端去，那么需要将这些key/value值拼接到一块，减少与partition相关的索引记录。 </p>
<p>​        在针对每个reduce端而合并数据时，有些数据可能像这样：“aaa”/1， “aaa”/1。对于WordCount例子，就是简单地统计单词出现的次数，如果在同一个map task的结果中有很多个像“aaa”一样出现多次的key，我们就应该把它们的值合并到一块，这个过程叫reduce也叫combine。但MapReduce的术语中，reduce只指reduce端执行从多个map task取数据做计算的过程。除reduce外，非正式地合并数据只能算做combine了。其实大家知道的，MapReduce中将Combiner等同于Reducer。 </p>
<p>​        如果client设置过Combiner，那么现在就是使用Combiner的时候了。将有相同key的key/value对的value加起来，减少溢写到磁盘的数据量。Combiner会优化MapReduce的中间结果，所以它在整个模型中会多次使用。那哪些场景才能使用Combiner呢？从这里分析，Combiner的输出是Reducer的输入，Combiner绝不能改变最终的计算结果。所以从我的想法来看，Combiner只应该用于那种Reduce的输入key/value与输出key/value类型完全一致，且不影响最终结果的场景。比如累加，最大值等。Combiner的使用一定得慎重，如果用好，它对job执行效率有帮助，反之会影响reduce的最终结果。 </p>
<ol>
<li>每次溢写会在磁盘上生成一个溢写文件，如果map的输出结果真的很大，有多次这样的溢写发生，磁盘上相应的就会有多个溢写文件存在。当map task真正完成时，内存缓冲区中的数据也全部溢写到磁盘中形成一个溢写文件。最终磁盘中会至少有一个这样的溢写文件存在(如果map的输出结果很少，当map执行完成时，只会产生一个溢写文件)，因为最终的文件只有一个，所以需要将这些溢写文件归并到一起，这个过程就叫做Merge。Merge是怎样的？如前面的例子，“aaa”从某个map task读取过来时值是5，从另外一个map 读取时值是8，因为它们有相同的key，所以得merge成group。什么是group。对于“aaa”就是像这样的：{“aaa”, [5, 8, 2, …]}，数组中的值就是从不同溢写文件中读取出来的，然后再把这些值加起来。请注意，因为merge是将多个溢写文件合并到一个文件，所以可能也有相同的key存在，在这个过程中如果client设置过Combiner，也会使用Combiner来合并相同的key。 </li>
</ol>
<p>​        至此，map端的所有工作都已结束，最终生成的这个文件也存放在TaskTracker够得着的某个本地目录内。每个reduce task不断地通过RPC从JobTracker那里获取map task是否完成的信息，如果reduce task得到通知，获知某台TaskTracker上的map task执行完成，Shuffle的后半段过程开始启动。 </p>
<p>​        简单地说，reduce task在执行之前的工作就是不断地拉取当前job里每个map task的最终结果，然后对从不同地方拉取过来的数据不断地做merge，也最终形成一个文件作为reduce task的输入文件。见下图：</p>
<p><img src="http://dl.iteye.com/upload/attachment/456527/608c7e08-896d-3697-a57e-a8ca60cf79ea.jpg" alt="img"></p>
<p>​        如map 端的细节图，Shuffle在reduce端的过程也能用图上标明的三点来概括。当前reduce copy数据的前提是它要从JobTracker获得有哪些map task已执行结束，这段过程不表，有兴趣的朋友可以关注下。Reducer真正运行之前，所有的时间都是在拉取数据，做merge，且不断重复地在做。如前面的方式一样，下面我也分段地描述reduce 端的Shuffle细节： </p>
<ol>
<li><p>Copy过程，简单地拉取数据。Reduce进程启动一些数据copy线程(Fetcher)，通过HTTP方式请求map task所在的TaskTracker获取map task的输出文件。因为map task早已结束，这些文件就归TaskTracker管理在本地磁盘中。 </p>
</li>
<li><p>Merge阶段。这里的merge如map端的merge动作，只是数组中存放的是不同map端copy来的数值。Copy过来的数据会先放入内存缓冲区中，这里的缓冲区大小要比map端的更为灵活，它基于JVM的heap size设置，因为Shuffle阶段Reducer不运行，所以应该把绝大部分的内存都给Shuffle用。这里需要强调的是，merge有三种形式：1)内存到内存  2)内存到磁盘  3)磁盘到磁盘。默认情况下第一种形式不启用，让人比较困惑，是吧。当内存中的数据量到达一定阈值，就启动内存到磁盘的merge。与map 端类似，这也是溢写的过程，这个过程中如果你设置有Combiner，也是会启用的，然后在磁盘中生成了众多的溢写文件。第二种merge方式一直在运行，直到没有map端的数据时才结束，然后启动第三种磁盘到磁盘的merge方式生成最终的那个文件。 </p>
</li>
<li><p>Reducer的输入文件。不断地merge后，最后会生成一个“最终文件”。为什么加引号？因为这个文件可能存在于磁盘上，也可能存在于内存中。对我们来说，当然希望它存放于内存中，直接作为Reducer的输入，但默认情况下，这个文件是存放于磁盘中的。至于怎样才能让这个文件出现在内存中，之后的<a href="http://langyu.iteye.com/blog/1341267" target="_blank" rel="noopener">性能优化篇</a>我再说。当Reducer的输入文件已定，整个Shuffle才最终结束。然后就是Reducer执行，把结果放到HDFS上。 </p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/19/数据倾斜的解决方法/" title="数据倾斜（转）" itemprop="url">数据倾斜（转）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-19T08:20:39.334Z" itemprop="datePublished"> 发表于 2018-06-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h3 id="数据倾斜介绍"><a href="#数据倾斜介绍" class="headerlink" title="数据倾斜介绍"></a>数据倾斜介绍</h3><p>简单的讲，数据倾斜就是我们在计算数据的时候，数据的分散度不够，导致大量的数据集中到了一台或者几台机器上计算，这些数据的计算速度远远低于平均计算速度，导致整个计算过程过慢。 </p>
<p>在做Shuffle阶段的优化过程中，遇到了数据倾斜的问题，造成了对一些情况下优化效果不明显。主要是因为在Job完成后的所得到的Counters是整个Job的总和，优化是基于这些Counters得出的平均值，而由于数据倾斜的原因造成map处理数据量的差异过大，使得这些平均值能代表的价值降低。Hive的执行是分阶段的，map处理数据量的差异取决于上一个stage的reduce输出，所以如何将数据均匀的分配到各个reduce中，就是解决数据倾斜的根本所在。规避错误来更好的运行比解决错误更高效。在查看了一些资料后，总结如下。</p>
<p>1数据倾斜的原因 </p>
<p>1.1操作：</p>
<table>
<thead>
<tr>
<th>关键词</th>
<th>情形</th>
<th>后果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Join</td>
<td>其中一个表较小，但是key集中</td>
<td>分发到某一个或几个Reduce   上的数据远       高于平均值</td>
</tr>
<tr>
<td></td>
<td>大表与大表，但是分桶的判断字段0值或空值过多</td>
<td>这些空值都由一个reduce     处理，灰常慢</td>
</tr>
<tr>
<td>group by</td>
<td>group by 维度过小，某值的数量过多</td>
<td>处理某值的reduce灰常耗时</td>
</tr>
<tr>
<td>Count Distinct</td>
<td>某特殊值过多</td>
<td>处理此特殊值的reduce耗时</td>
</tr>
</tbody>
</table>
<p>1.2原因：</p>
<p>1)、key分布不均匀</p>
<p>2)、业务数据本身的特性</p>
<p>3)、建表时考虑不周</p>
<p>4)、某些SQL语句本身就有数据倾斜</p>
<p>1.3表现：</p>
<p>任务进度长时间维持在99%（或100%），查看任务监控页面，发现只有少量（1个或几个）reduce子任务未完成。因为其处理的数据量和其他reduce差异过大。</p>
<p>单一reduce的记录数与平均记录数差异过大，通常可能达到3倍甚至更多。 最长时长远大于平均时长。</p>
<p>2数据倾斜的解决方案</p>
<p>2.1参数调节：</p>
<p>hive.map.aggr = true</p>
<p>Map 端部分聚合，相当于Combiner</p>
<p>hive.groupby.skewindata=true</p>
<p>有数据倾斜的时候进行负载均衡，当选项设定为 true，生成的查询计划会有两个 MR Job。第一个 MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key 有可能被分发到不同的 Reduce 中，从而达到负载均衡的目的；第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中（这个过程可以保证相同的 Group By Key 被分布到同一个 Reduce 中），最后完成最终的聚合操作。</p>
<p>2.2 SQL语句调节：</p>
<p>如何Join：</p>
<p>关于驱动表的选取，选用join key分布最均匀的表作为驱动表</p>
<p>做好列裁剪和filter操作，以达到两表做join的时候，数据量相对变小的效果。</p>
<p>大小表Join：</p>
<p>使用map join让小的维度表（1000条以下的记录条数） 先进内存。在map端完成reduce.</p>
<p>大表Join大表：</p>
<p>把空值的key变成一个字符串加上随机数，把倾斜的数据分到不同的reduce上，由于null值关联不上，处理后并不影响最终结果。</p>
<p>count distinct大量相同特殊值</p>
<p>count distinct时，将值为空的情况单独处理，如果是计算count distinct，可以不用处理，直接过滤，在最后结果中加1。如果还有其他计算，需要进行group by，可以先将值为空的记录单独处理，再和其他计算结果进行union。</p>
<p>group by维度过小：</p>
<p>采用sum() group by的方式来替换count(distinct)完成计算。</p>
<p>特殊情况特殊处理：</p>
<p>在业务逻辑优化效果的不大情况下，有些时候是可以将倾斜的数据单独拿出来处理。最后union回去。</p>
<p>3典型的业务场景</p>
<p>3.1空值产生的数据倾斜</p>
<p>场景：如日志中，常会有信息丢失的问题，比如日志中的 user_id，如果取其中的 user_id 和 用户表中的user_id 关联，会碰到数据倾斜的问题。</p>
<p>解决方法1： user_id为空的不参与关联</p>
<p>select * from log a</p>
<p>  join users b</p>
<p>  on a.user_id is not null</p>
<p>  and a.user_id = b.user_id</p>
<p>union all</p>
<p>select * from log a</p>
<p>  where a.user_id is null;</p>
<p>解决方法2 ：赋与空值分新的key值</p>
<p>select *</p>
<p>  from log a</p>
<p>  left outer join users b</p>
<p>  on case when a.user_id is null then concat(‘hive’,rand() ) else a.user_id end = b.user_id;</p>
<p>结论：方法2比方法1效率更好，不但io少了，而且作业数也少了。解决方法1中 log读取两次，jobs是2。解决方法2 job数是1 。这个优化适合无效 id (比如 -99 , ’’, null 等) 产生的倾斜问题。把空值的 key 变成一个字符串加上随机数，就能把倾斜的数据分到不同的reduce上 ,解决数据倾斜问题。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/05/31/奇异值分解(SVD)/" title="奇异值分解(SVD)" itemprop="url">奇异值分解(SVD)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-05-31T12:33:20.236Z" itemprop="datePublished"> 发表于 2018-05-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>奇异值分解（singular Value Decomposition），简称SVD，线性代数中矩阵分解的方法。假如有一个矩阵A，对它进行奇异值分解，可以得到三个矩阵：</p>
<p><img src="http://120.25.221.136/images/svd/svd.png" alt=""></p>
<p>分解矩阵的大小为下面：</p>
<p><img src="http://120.25.221.136/images/svd/fenjie.png" alt=""></p>
<p>在第二个矩阵中的矩阵特点是除了对角线不为0其余的元素都为0，并且对角线元素都是按照从大到小的排序。将上面中间矩阵只保存少数元素。</p>
<p><img src="http://120.25.221.136/images/svd/fenjie2.png" alt="">实际应用中，我们仅需保留着三个比较小的矩阵，就能表示A，不仅节省存储量，在计算的时候更是减少了计算量。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="https://github.com/pengyuanqiuqiu" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>



  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.nowcoder.com/" target="_blank" title="牛客网">牛客网</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.acmcoder.com/index" target="_blank" title="赛码网">赛码网</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="http://www.163.com/rss/" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="400" class="share_self"  frameborder="0" scrolling="no" src="https://widget.weibo.com/weiboshow/index.php?language=&width=0&height=400&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=2871001534&verifier=2889e96f&colors=d6f3f7,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m jianyu. <br/>
			Let&#39;s go!</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2871001534" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/pengyuanqiuqiu" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/peng-yuan-19-57?utm_source=qq&amp;utm_medium=social" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:987219258@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by © 2018 
		
		<a href="https://pengyuanqiuqiu.github.io/" target="_blank" title="PengYuan">PengYuan</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
