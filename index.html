
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Jianyu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="PengYuan">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Jianyu">
<meta property="og:url" content="https://pengyuanqiuqiu.github.io/index.html">
<meta property="og:site_name" content="Jianyu">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jianyu">

    
    <link rel="alternative" href="http://www.163.com/rss/" title="Jianyu" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Jianyu" title="Jianyu"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Jianyu">Jianyu</a></h1>
				<h2 class="blog-motto">Learn more and more</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:pengyuanqiuqiu.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/09/PCA的数学原理/" title="PCA的数学原理(转)" itemprop="url">PCA的数学原理(转)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-09T12:22:31.986Z" itemprop="datePublished"> 发表于 2018-07-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>​       PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。网上关于PCA的文章有很多，但是大多数只描述了PCA的分析过程，而没有讲述其中的原理。这篇文章的目的是介绍PCA的基本数学原理，帮助读者了解PCA的工作机制是什么。</p>
<p>​       当然我并不打算把文章写成纯数学文章，而是希望用直观和易懂的方式叙述PCA的数学原理，所以整个文章不会引入严格的数学推导。希望读者在看完这篇文章后能更好的明白PCA的工作原理。</p>
<h3 id="数据的向量表示及降维问题"><a href="#数据的向量表示及降维问题" class="headerlink" title="数据的向量表示及降维问题"></a>数据的向量表示及降维问题</h3><p>​    一般情况下，在数据挖掘和机器学习中，数据被表示为向量。例如某个淘宝店2012年全年的流量及交易情况可以看成一组记录的集合，其中每一天的数据是一条记录，格式如下：</p>
<p>(日期, 浏览量, 访客数, 下单数, 成交数, 成交金额)</p>
<p>​    其中“日期”是一个记录标志而非度量值，而数据挖掘关心的大多是度量值，因此如果我们忽略日期这个字段后，我们得到一组记录，每条记录可以被表示为一个五维向量，其中一条看起来大约是这个样子：</p>
<p><img src="http://120.25.221.136/images/pca/pca1.png" alt=""></p>
<p>​    注意这里我用了转置，因为习惯上使用列向量表示一条记录（后面会看到原因），本文后面也会遵循这个准则。不过为了方便有时我会省略转置符号，但我们说到向量默认都是指列向量。</p>
<p>​    我们当然可以对这一组五维向量进行分析和挖掘，不过我们知道，很多机器学习算法的复杂度和数据的维数有着密切关系，甚至与维数呈指数级关联。当然，这里区区五维的数据，也许还无所谓，但是实际机器学习中处理成千上万甚至几十万维的情况也并不罕见，在这种情况下，机器学习的资源消耗是不可接受的，因此我们必须对数据进行降维。</p>
<p>​    降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。</p>
<p>​    <strong>举个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。</strong></p>
<p>​    当然上面是一个极端的情况，在现实中也许不会出现，不过类似的情况还是很常见的。例如上面淘宝店铺的数据，从经验我们可以知道，“浏览量”和“访客数”往往具有较强的相关关系，而“下单数”和“成交数”也具有较强的相关关系。这里我们非正式的使用“相关关系”这个词，可以直观理解为“当某一天这个店铺的浏览量较高（或较低）时，我们应该很大程度上认为这天的访客数也较高（或较低）”。后面的章节中我们会给出相关性的严格数学定义。</p>
<p>​    这种情况表明，如果我们删除浏览量或访客数其中一个指标，我们应该期待并不会丢失太多信息。因此我们可以删除一个，以降低机器学习算法的复杂度。</p>
<p>​    上面给出的是降维的朴素思想描述，可以有助于直观理解降维的动机和可行性，但并不具有操作指导意义。例如，我们到底删除哪一列损失的信息才最小？亦或根本不是单纯删除几列，而是通过某些变换将原始数据变为更少的列但又使得丢失的信息最小？到底如何度量丢失信息的多少？如何根据原始数据决定具体的降维操作步骤？</p>
<p>​    要回答上面的问题，就要对降维问题进行数学化和形式化的讨论。而PCA是一种具有严格数学基础并且已被广泛采用的降维方法。下面我不会直接描述PCA，而是通过逐步分析问题，让我们一起重新“发明”一遍PCA。</p>
<h3 id="向量的表示及基变换"><a href="#向量的表示及基变换" class="headerlink" title="向量的表示及基变换"></a>向量的表示及基变换</h3><p>既然我们面对的数据被抽象为一组向量，那么下面有必要研究一些向量的数学性质。而这些数学性质将成为后续导出PCA的理论基础。</p>
<h4 id="内积与投影"><a href="#内积与投影" class="headerlink" title="内积与投影"></a>内积与投影</h4><p>下面先来看一个高中就学过的向量运算：内积。两个维数相同的向量的内积被定义为：</p>
<p><img src="http://120.25.221.136/images/pca/pca2.png" alt=""></p>
<p>内积运算将两个向量映射为一个实数。其计算方式非常容易理解，但是其意义并不明显。下面我们分析内积的几何意义。假设A和B是两个n维向量，我们知道n维向量可以等价表示为n维空间中的一条从原点发射的有向线段，为了简单起见我们假设A和B均为二维向量，则<img src="http://120.25.221.136/images/pca/pcaa.png" alt="">则在二维平面上A和B可以用两条发自原点的有向线段表示，见下图：</p>
<p><img src="http://120.25.221.136/images/pca/pca3.png" alt=""></p>
<p>现在我们从A点向B所在直线引一条垂线。我们知道垂线与B的交点叫做A在B上的投影，再设A与B的夹角是a，则投影的矢量长度为<img src="http://120.25.221.136/images/pca/1.png" alt="">，其中<img src="http://120.25.221.136/images/pca/2.png" alt="">是向量A的模，也就是A线段的标量长度。</p>
<p>注意这里我们专门区分了矢量长度和标量长度，标量长度总是大于等于0，值就是线段的长度；而矢量长度可能为负，其绝对值是线段长度，而符号取决于其方向与标准方向相同或相反。</p>
<p>到这里还是看不出内积和这东西有什么关系，不过如果我们将内积表示为另一种我们熟悉的形式：</p>
<p><img src="http://120.25.221.136/images/pca/pca5.png" alt=""></p>
<p>现在事情似乎是有点眉目了：A与B的内积等于A到B的投影长度乘以B的模。再进一步，如果我们假设B的模为1，即让|B|=1|B|=1，那么就变成了：</p>
<p><img src="http://120.25.221.136/images/pca/pca6.png" alt=""></p>
<p>也就是说，<strong>设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度</strong>！这就是内积的一种几何解释，也是我们得到的第一个重要结论。在后面的推导中，将反复使用这个结论。</p>
<h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><p>下面我们继续在二维空间内讨论向量。上文说过，一个二维向量可以对应二维笛卡尔直角坐标系中从原点出发的一个有向线段。例如下面这个向量：</p>
<p><img src="http://120.25.221.136/images/pca/pca7.png" alt=""></p>
<p>在代数表示方面，我们经常用线段终点的点坐标表示向量，例如上面的向量可以表示为(3,2)，这是我们再熟悉不过的向量表示。</p>
<p>不过我们常常忽略，<strong>只有一个(3,2)本身是不能够精确表示一个向量的</strong>。我们仔细看一下，这里的3实际表示的是向量在x轴上的投影值是3，在y轴上的投影值是2。也就是说我们其实隐式引入了一个定义：以x轴和y轴上正方向长度为1的向量为标准。那么一个向量(3,2)实际是说在x轴投影为3而y轴的投影为2。注意投影是一个矢量，所以可以为负。</p>
<p>更正式的说，向量(x,y)实际上表示线性组合：</p>
<p><img src="http://120.25.221.136/images/pca/pca8.png" alt=""></p>
<p>不难证明所有二维向量都可以表示为这样的线性组合。此处(1,0)和(0,1)叫做二维空间中的一组基。</p>
<p><img src="http://120.25.221.136/images/pca/pca9.png" alt=""></p>
<p>所以，<strong>要准确描述向量，首先要确定一组基，然后给出在基所在的各个直线上的投影值，就可以了</strong>。只不过我们经常省略第一步，而默认以(1,0)和(0,1)为基。</p>
<p>我们之所以默认选择(1,0)和(0,1)为基，当然是比较方便，因为它们分别是x和y轴正方向上的单位向量，因此就使得二维平面上点坐标和向量一一对应，非常方便。但实际上任何两个线性无关的二维向量都可以成为一组基，所谓线性无关在二维平面内可以直观认为是两个不在一条直线上的向量。</p>
<p>例如，(1,1)和(-1,1)也可以成为一组基。一般来说，我们希望基的模是1，因为从内积的意义可以看到，如果基的模是1，那么就可以方便的用向量点乘基而直接获得其在新基上的坐标了！实际上，对应任何一个向量我们总可以找到其同方向上模为1的向量，只要让两个分量分别除以模就好了。例如，上面的基可以变为<img src="http://120.25.221.136/images/pca/pca10.png" alt=""></p>
<p>现在，我们想获得(3,2)在新基上的坐标，即在两个方向上的投影矢量值，那么根据内积的几何意义，我们只要分别计算(3,2)和两个基的内积，不难得到新的坐标为<img src="http://120.25.221.136/images/pca/pca11.png" alt="">。下图给出了新的基以及(3,2)在新基上坐标值的示意图：<img src="http://120.25.221.136/images/pca/pca12.png" alt=""></p>
<p>另外这里要注意的是，我们列举的例子中基是正交的（即内积为0，或直观说相互垂直），但可以成为一组基的唯一要求就是线性无关，非正交的基也是可以的。不过因为正交基有较好的性质，所以一般使用的基都是正交的。</p>
<h4 id="基变换的矩阵表示"><a href="#基变换的矩阵表示" class="headerlink" title="基变换的矩阵表示"></a>基变换的矩阵表示</h4><p>下面我们找一种简便的方式来表示基变换。还是拿上面的例子，想一下，将(3,2)变换为新基上的坐标，就是用(3,2)与第一个基做内积运算，作为第一个新的坐标分量，然后用(3,2)与第二个基做内积运算，作为第二个新坐标的分量。实际上，我们可以用矩阵相乘的形式简洁的表示这个变换：</p>
<p><img src="http://120.25.221.136/images/pca/pca13.png" alt=""></p>
<p>太漂亮了！其中矩阵的两行分别为两个基，乘以原向量，其结果刚好为新基的坐标。可以稍微推广一下，如果我们有m个二维向量，只要将二维向量按列排成一个两行m列矩阵，然后用“基矩阵”乘以这个矩阵，就得到了所有这些向量在新基下的值。例如(1,1)，(2,2)，(3,3)，想变换到刚才那组基上，则可以这样表示：</p>
<p><img src="http://120.25.221.136/images/pca/pca15.png" alt=""></p>
<p>于是一组向量的基变换被干净的表示为矩阵的相乘。</p>
<p><strong>一般的，如果我们有M个N维向量，想将其变换为由R个N维向量表示的新空间中，那么首先将R个基按行组成矩阵A，然后将向量按列组成矩阵B，那么两矩阵的乘积AB就是变换结果，其中AB的第m列为A中第m列变换后的结果</strong>。</p>
<p>数学表示为：<img src="http://120.25.221.136/images/pca/pca16.png" alt=""></p>
<p>其中<img src="http://120.25.221.136/images/pca/pca17.png" alt="">是一个行向量，表示第i个基，<img src="http://120.25.221.136/images/pca/pca18.png" alt="">是一个列向量，表示第j个原始数据记录。</p>
<p>特别要注意的是，这里R可以小于N，而R决定了变换后数据的维数。也就是说，我们可以将一N维数据变换到更低维度的空间中去，变换后的维度取决于基的数量。因此这种矩阵相乘的表示也可以表示降维变换。</p>
<p>最后，上述分析同时给矩阵相乘找到了一种物理解释：<strong>两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去</strong>。更抽象的说，一个矩阵可以表示一种线性变换。很多同学在学线性代数时对矩阵相乘的方法感到奇怪，但是如果明白了矩阵相乘的物理意义，其合理性就一目了然了。</p>
<h3 id="协方差矩阵及优化目标"><a href="#协方差矩阵及优化目标" class="headerlink" title="协方差矩阵及优化目标"></a>协方差矩阵及优化目标</h3><p>上面我们讨论了选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。或者说，如果我们有一组N维向量，现在要将其降到K维（K小于N），那么我们应该如何选择K个基才能最大程度保留原有的信息？</p>
<p>要完全数学化这个问题非常繁杂，这里我们用一种非形式化的直观方法来看这个问题。</p>
<p>为了避免过于抽象的讨论，我们仍以一个具体的例子展开。假设我们的数据由五条记录组成，将它们表示成矩阵形式：</p>
<p><img src="http://120.25.221.136/images/pca/pca19.png" alt=""></p>
<p>其中每一列为一条数据记录，而一行为一个字段。为了后续处理方便，我们首先将每个字段内所有值都减去字段均值，其结果是将每个字段都变为均值为0（这样做的道理和好处后面会看到）。</p>
<p>我们看上面的数据，第一个字段均值为2，第二个字段均值为3，所以变换后：<img src="http://120.25.221.136/images/pca/pca20.png" alt=""></p>
<p>我们可以看下五条数据在平面直角坐标系内的样子：</p>
<p><img src="http://120.25.221.136/images/pca/pca21.png" alt=""></p>
<p>​    现在问题来了：如果我们必须使用一维来表示这些数据，又希望尽量保留原始的信息，你要如何选择？</p>
<p>​    通过上一节对基变换的讨论我们知道，这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。这是一个实际的二维降到一维的问题。</p>
<p>那么如何选择这个方向（或者说基）才能尽量保留最多的原始信息呢？一种直观的看法是：希望投影后的投影值尽可能分散。</p>
<p>​    以上图为例，可以看出如果向x轴投影，那么最左边的两个点会重叠在一起，中间的两个点也会重叠在一起，于是本身四个各不相同的二维点投影后只剩下两个不同的值了，这是一种严重的信息丢失，同理，如果向y轴投影最上面的两个点和分布在x轴上的两个点也会重叠。所以看来x和y轴都不是最好的投影选择。我们直观目测，如果向通过第一象限和第三象限的斜线投影，则五个点在投影后还是可以区分的。</p>
<p>下面，我们用数学方法表述这个问题。</p>
<h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>上文说到，我们希望投影后投影值尽可能分散，而这种分散程度，可以用数学上的方差来表述。此处，一个字段的方差可以看做是每个元素与字段均值的差的平方和的均值，即：<img src="http://120.25.221.136/images/pca/pca22.png" alt=""></p>
<p>由于上面我们已经将每个字段的均值都化为0了，因此方差可以直接用每个元素的平方和除以元素个数表示：<img src="http://120.25.221.136/images/pca/pca88.png" alt=""></p>
<p>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。</p>
<h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><p>对于上面二维降成一维的问题来说，找到那个使得方差最大的方向就可以了。不过对于更高维，还有一个问题需要解决。考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。</p>
<p>如果我们还是单纯只选择方差最大的方向，很明显，这个方向与第一个方向应该是“几乎重合在一起”，显然这样的维度是没有用的，因此，应该有其他约束条件。从直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。</p>
<p>数学上可以用两个字段的协方差表示其相关性，由于已经让每个字段均值为0，则：</p>
<p><img src="http://120.25.221.136/images/pca/pca23.png" alt=""></p>
<p>可以看到，在字段均值为0的情况下，两个字段的协方差简洁的表示为其内积除以元素数m。</p>
<p>当协方差为0时，表示两个字段完全独立。为了让协方差为0，我们选择第二个基时只能在与第一个基正交的方向上选择。因此最终选择的两个方向一定是正交的。</p>
<p>至此，我们得到了降维问题的优化目标：<strong>将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）</strong>。</p>
<h4 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h4><p>上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。</p>
<p>我们看到，最终要达到的目的与字段内方差及字段间协方差有密切关系。因此我们希望能将两者统一表示，仔细观察发现，两者均可以表示为内积的形式，而内积又与矩阵相乘密切相关。于是我们来了灵感：</p>
<p>假设我们只有a和b两个字段，那么我们将它们按行组成矩阵X：<img src="http://120.25.221.136/images/pca/pca24.png" alt=""></p>
<p>然后我们用X乘以X的转置，并乘上系数1/m：<img src="http://120.25.221.136/images/pca/pca25.png" alt=""></p>
<p>奇迹出现了！这个矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。两者被统一到了一个矩阵的。</p>
<p>根据矩阵相乘的运算法则，这个结论很容易被推广到一般情况：</p>
<p><strong>设我们有m个n维数据记录，将其按列排成n乘m的矩阵X，设</strong><img src="http://120.25.221.136/images/pca/pca89.png" alt=""><strong>，则C是一个对称矩阵，其对角线分别个各个字段的方差，而第i行j列和j行i列元素相同，表示i和j两个字段的协方差</strong>。</p>
<h4 id="协方差矩阵对角化"><a href="#协方差矩阵对角化" class="headerlink" title="协方差矩阵对角化"></a>协方差矩阵对角化</h4><p>根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：</p>
<p>设原始数据矩阵X对应的协方差矩阵为C，而P是一组基按行组成的矩阵，设Y=PX，则Y为X对P做基变换后的数据。设Y的协方差矩阵为D，我们推导一下D与C的关系：<img src="http://120.25.221.136/images/pca/pca26.png" alt=""></p>
<p>现在事情很明白了！我们要找的P不是别的，而是能让原始协方差矩阵对角化的P。换句话说，优化目标变成了<strong>寻找一个矩阵P，满足</strong><img src="http://120.25.221.136/images/pca/pca90.png" alt=""><strong>是一个对角矩阵，并且对角元素按从大到小依次排列，那么P的前K行就是要寻找的基，用P的前K行组成的矩阵乘以X就使得X从N维降到了K维并满足上述优化条件</strong>。</p>
<p>至此，我们离“发明”PCA还有仅一步之遥！</p>
<p>现在所有焦点都聚焦在了协方差矩阵对角化问题上，有时，我们真应该感谢数学家的先行，因为矩阵对角化在线性代数领域已经属于被玩烂了的东西，所以这在数学上根本不是问题。</p>
<p>由上文知道，协方差矩阵C是一个是对称矩阵，在线性代数上，实对称矩阵有一系列非常好的性质：</p>
<p>1）实对称矩阵不同特征值对应的特征向量必然正交。</p>
<p>2）设特征向量λ重数为r，则必然存在r个线性无关的特征向量对应于λ，因此可以将这r个特征向量单位正交化。</p>
<p>由上面两条可知，一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量，设这n个特征向量为<img src="http://120.25.221.136/images/pca/pca27.png" alt="">我们将其按列组成矩阵：<img src="http://120.25.221.136/images/pca/pca27.png" alt=""></p>
<p>则对协方差矩阵C有如下结论：<img src="http://120.25.221.136/images/pca/pca29.png" alt="">其中Λ为对角矩阵，其对角元素为各特征向量对应的特征值（可能有重复）。</p>
<p>以上结论不再给出严格的数学证明，对证明感兴趣的朋友可以参考线性代数书籍关于“实对称矩阵对角化”的内容。</p>
<p>到这里，我们发现我们已经找到了需要的矩阵P：<img src="http://120.25.221.136/images/pca/pca30.png" alt="">P是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是C的一个特征向量。如果设P按照Λ中特征值的从大到小，将特征向量从上到下排列，则用P的前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。</p>
<p>至此我们完成了整个PCA的数学原理讨论。在下面的一节，我们将给出PCA的一个实例。算法及实例</p>
<p>为了巩固上面的理论，我们在这一节给出一个具体的PCA实例。</p>
<h4 id="PCA算法"><a href="#PCA算法" class="headerlink" title="PCA算法"></a>PCA算法</h4><p>总结一下PCA的算法步骤：</p>
<p>设有m条n维数据。</p>
<p>1）将原始数据按列组成n行m列矩阵X</p>
<p>2）将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</p>
<p>3）求出协方差矩阵<img src="http://120.25.221.136/images/pca/pca31.png" alt=""></p>
<p>4）求出协方差矩阵的特征值及对应的特征向量</p>
<p>5）将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</p>
<p>6）<img src="http://120.25.221.136/images/pca/pca32.png" alt="">即为降维到k维后的数据</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/08/深度学习权重初始化/" title="深度学习权重初始化(转)" itemprop="url">深度学习权重初始化(转)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-08T05:32:19.166Z" itemprop="datePublished"> 发表于 2018-07-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>权值初始化的方法主要有：常量初始化（constant）、高斯分布初始化（gaussian）、positive_unitball初始化、均匀分布初始化（uniform）、xavier初始化、msra初始化、双线性初始化（bilinear）</p>
<p><strong>常量初始化(constant)</strong></p>
<p>​       把权值或者偏置初始化为一个常数，具体是什么常数，可以自己定义</p>
<p><strong>高斯分布初始化（gaussian）</strong></p>
<p>​        正态初始化   如：w = tf.Variable(tf.random_normal(shape, stddev=0.01))，缺点是：</p>
<p>标准差太大，容易梯度消失和梯度爆炸，合适的标准差在深层网络中，容易出现梯度弥散。</p>
<p>梯度弥散：</p>
<p>​        靠近输出层的hidden layer 梯度大，参数更新快，所以很快就会收敛；而靠近输入层的hidden layer 梯度小，参数更新慢，几乎就和初始状态一样，随机分布。这种现象就是梯度弥散（vanishing gradient problem）。而在另一种情况中，前面layer的梯度通过训练变大，而后面layer的梯度指数级增大，这种现象又叫做梯度爆炸(exploding gradient problem)。总的来说，就是在这个深度网络中，梯度相当不稳定(unstable)。可以通过relu等激活函数替代，可以加上maxout层。</p>
<p><strong>positive_unitball初始化</strong></p>
<p>​       让每一个神经元的输入的权值和为 1，例如：一个神经元有100个输入，让这100个输入的权值和为1.  首先给这100个权值赋值为在（0，1）之间的均匀分布，然后，每一个权值再除以它们的和就可以啦。这么做，可以有助于防止权值初始化过大，从而防止激活函数（sigmoid函数）进入饱和区。所以，它应该比较适合simgmoid形的激活函数</p>
<p><strong>均匀分布初始化（uniform）</strong></p>
<p>​       将权值与偏置进行均匀分布的初始化，用min 与 max 来控制它们的的上下限，默认为（0，1）</p>
<p><strong>xavier初始化</strong></p>
<p>​       对于权值的分布：均值为0，方差为（1 / 输入的个数） 的 均匀分布。如果我们更注重前向传播的话，我们可以选择 fan_in，即正向传播的输入个数；如果更注重后向传播的话，我们选择 fan_out, 因为在反向传播的时候，fan_out就是神经元的输入个数；如果两者都考虑的话，就选  average = (fan_in + fan_out) /2。对于ReLU激活函数来说，XavierFiller初始化也是很适合。关于该初始化方法，具体可以参考<a href="https://zhuanlan.zhihu.com/p/22028079" target="_blank" rel="noopener">文章1</a>、<a href="https://zhuanlan.zhihu.com/p/22044472" target="_blank" rel="noopener">文章2</a>，该方法假定激活函数是线性的。</p>
<p><strong>msra初始化</strong></p>
<p>​       对于权值的分布：基于均值为0，方差为( 2/输入的个数)的高斯分布；它特别适合 ReLU激活函数，该方法主要是基于Relu函数提出的，推导过程类似于xavier，可以参考<a href="http://blog.csdn.net/shuzfan/article/details/51347572" target="_blank" rel="noopener">博客</a>。</p>
<p><strong>双线性初始化（bilinear）</strong></p>
<p>​      常用在反卷积神经网络里的权值初始化</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/06/决策树算法/" title="决策树ID3/C4.5/CART算法比较" itemprop="url">决策树ID3/C4.5/CART算法比较</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-06T02:31:04.711Z" itemprop="datePublished"> 发表于 2018-07-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="决策树介绍"><a href="#决策树介绍" class="headerlink" title="决策树介绍"></a>决策树介绍</h3><p>​          决策树模型在监督学习中非常常见，可用于分类（二分类、多分类）和回归。虽然将多棵弱决策树的Bagging、Random Forest、Boosting等tree ensembel 模型更为常见，但是“完全生长”决策树因为其简单直观，具有很强的解释性，一般而言一棵“完全生长”的决策树包含，<strong>特征选择、决策树构建、剪枝</strong>三个过程。决策树是一种<strong>贪心算法</strong>，每次选取的分割数据的特征都是当前的最佳选择，并不关心是否达到最优。</p>
<h3 id="决策树的优缺点"><a href="#决策树的优缺点" class="headerlink" title="决策树的优缺点"></a>决策树的优缺点</h3><p>优点：</p>
<ol>
<li>决策树算法中学习简单的决策规则建立决策树模型的过程非常容易理解，</li>
<li>决策树模型可以可视化，非常直观</li>
<li>应用范围广，可用于分类和回归，而且非常容易做多类别的分类</li>
<li>能够处理数值型和连续的样本特征</li>
</ol>
<p>​    缺点：</p>
<ol>
<li>很容易在训练数据中生成复杂的树结构，造成过拟合（overfitting）。剪枝可以缓解过拟合的负作用，常用方法是限制树的高度、叶子节点中的最少样本数量。</li>
<li>学习一棵最优的决策树被认为是NP-Complete问题。实际中的决策树是基于启发式的贪心算法建立的，这种算法不能保证建立全局最优的决策树。Random Forest 引入随机能缓解这个问题</li>
</ol>
<h4 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h4><p>​        ID3决策树可以有多个分支，但是不能处理特征值为连续的情况。决策树是一种贪心算法，每次选取的分割数据的特征都是当前的最佳选择，并不关心是否达到最优。在ID3中，每次根据“最大信息熵增益”选取当前最佳的特征来分割数据，并按照该特征的所有取值来切分，也就是说如果一个特征有4种取值，数据将被切分4份，一旦按某特征切分后，该特征在之后的算法执行中，将不再起作用，所以有观点认为这种切分方式过于迅速。ID3算法十分简单，核心是根据“最大信息熵增益”原则选择划分当前数据集的最好特征，信息熵是信息论里面的概念，是信息的度量方式，不确定度越大或者说越混乱，熵就越大。在建立决策树的过程中，根据特征属性划分数据，使得原本“混乱”的数据的熵(混乱度)减少，按照不同特征划分数据熵减少的程度会不一样。在ID3中选择熵减少程度最大的特征来划分数据（贪心），也就是“最大信息熵增益”原则。</p>
<p>缺点：①切分过于迅速；</p>
<p>②不能直接处理特征值为连续的情况，只有事先将连续型特征转换成离散型，但这转换过程中会破坏连续型变量的内在性质;</p>
<p>③ </p>
<p><img src="http://120.25.221.136/images/dt/tree.png" alt=""></p>
<h4 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a><strong>C4.5算法</strong></h4><p>C4.5是Ross Quinlan在1993年在ID3的基础上改进而提出的。.ID3采用的信息增益度量存在一个缺点，它一般会优先选择有较多属性值的Feature,因为属性值多的Feature会有相对较大的信息增益?(信息增益反映的给定一个条件以后不确定性减少的程度,必然是分得越细的数据集确定性更高,也就是条件熵越小,信息增益越大).为了避免这个不足C4.5中是用信息增益比率(gain ratio)来作为选择分支的准则。信息增益比率通过引入一个被称作分裂信息(Split information)的项来惩罚取值较多的Feature。除此之外，C4.5还弥补了ID3中不能处理特征属性值连续的问题。<strong>信息增益比本质： 是在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。一般为原集合信息熵。</strong></p>
<p><img src="http://120.25.221.136/images/dt/tree2.png" alt=""></p>
<p><strong>C4.5算法能够处理不完整的数据，常用的处理方法有以下三种：</strong></p>
<ul>
<li>给缺失属性赋予最常见的值。</li>
<li>丢弃含有缺失值的样本。</li>
<li>根据节点的样例上该属性值出现的情况赋一个概率值。</li>
</ul>
<h4 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a><strong>CART算法</strong></h4><p>CART（Classification and Regression tree）分类回归树由L.Breiman,J.Friedman,R.Olshen和C.Stone于1984年提出。ID3中根据属性值分割数据，之后该特征不会再起作用，这种快速切割的方式会影响算法的准确率。CART是一棵二叉树，采用二元切分法，每次把数据切成两份，分别进入左子树、右子树。而且每个非叶子节点都有两个孩子，所以CART的叶子节点比非叶子多1。相比ID3和C4.5，CART应用要多一些，既可以用于分类也可以用于回归。CART分类时，使用基尼指数（Gini）来选择最好的数据分割的特征，gini描述的是纯度，与信息熵的含义相似。CART中每一次迭代都会降低GINI系数。下图显示信息熵增益的一半，Gini指数，分类误差率三种评价指标非常接近。回归时使用均方差作为loss function。基尼系数的计算与信息熵增益的方式非常类似，公式如下：</p>
<p><img src="http://120.25.221.136/images/dt/tree3.png" alt=""></p>
<p><strong>三种方法对比：</strong></p>
<p><strong>ID3的缺点，倾向于选择水平数量较多的变量，可能导致训练得到一个庞大且深度浅的树；另外输入变量必须是分类变量（连续变量必须离散化）；最后无法处理空值。</strong></p>
<p><strong>C4.5选择了信息增益率替代信息增益。</strong></p>
<p><strong>CART以基尼系数替代熵；最小化不纯度而不是最大化信息增益。</strong></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/05/掌握Adaboost算法/" title="掌握Addaboost算法" itemprop="url">掌握Addaboost算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-05T09:13:00.522Z" itemprop="datePublished"> 发表于 2018-07-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="Adaboost介绍"><a href="#Adaboost介绍" class="headerlink" title="Adaboost介绍"></a>Adaboost介绍</h3><p>AdaBoost，是英文”Adaptive Boosting”（自适应增强）的缩写，由Yoav Freund和Robert Schapire在1995年提出。它的自适应在于：前一个基本分类器分错的样本会得到加强，加权后的全体样本再次被用来训练下一个基本分类器。同时，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数。</p>
<h3 id="Adaboost算法步骤"><a href="#Adaboost算法步骤" class="headerlink" title="Adaboost算法步骤"></a>Adaboost算法步骤</h3><p>具体说来，整个Adaboost 迭代算法就3步：</p>
<ol>
<li>初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1/N。</li>
<li>训练弱分类器。具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</li>
<li>将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。</li>
</ol>
<p>AdaBoost算法过程</p>
<p>​    给定训练数据集：<img src="http://120.25.221.136/images/adsboost/ada.jpg" alt="">，其中用于表示训练样本的类别标签<img src="http://120.25.221.136/images/adsboost/yi.jpg" alt="">，i=1,…,N。Adaboost的目的就是从训练数据中学习一系列弱分类器或基本分类器，然后将这些弱分类器组合成一个强分类器。</p>
<p>相关符号定义：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost2.jpg" alt=""></p>
<p>Adaboost的算法流程如下：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost4.jpg" alt=""></p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost5.jpg" alt=""></p>
<p>相关说明：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost7.jpg" alt=""></p>
<p>综合上面的推导，可得样本分错与分对时，其权值更新的公式为：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost8.jpg" alt=""></p>
<h3 id="AdaBoost实例讲解"><a href="#AdaBoost实例讲解" class="headerlink" title="AdaBoost实例讲解"></a>AdaBoost实例讲解</h3><p>例：给定如图所示的训练样本，弱分类器采用平行于坐标轴的直线，用Adaboost算法的实现强分类过程。</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost9.jpg" alt=""></p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost11.jpg" alt=""></p>
<p>数据分析：</p>
<p>   将这10个样本作为训练数据，根据X和Y的对应关系，可把这10个数据分为两类，图中用“+”表示类别1，用“O”表示类别-1。本例使用水平或者垂直的直线作为分类器，图中已经给出了三个弱分类器，即：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost12.jpg" alt=""></p>
<p>初始化：</p>
<p>   首先需要初始化训练样本数据的权值分布，每一个训练样本最开始时都被赋予相同的权值：wi=1/N，这样训练样本集的初始权值分布D1(i)：</p>
<p>   令每个权值w1i= 1/N = 0.1，其中，N = 10，i = 1,2, …, 10，然后分别对于t= 1,2,3, …等值进行迭代（t表示迭代次数，表示第t轮），下表已经给出训练样本的权值分布情况：</p>
<p><img src="http://120.25.221.136/images/adsboost/ada10.jpg" alt=""></p>
<p>第1次迭代t=1：</p>
<p>初试的权值分布D1为1/N（10个数据，每个数据的权值皆初始化为0.1），</p>
<p>D1=[0.1,  0.1, 0.1, 0.1, 0.1, 0.1,0.1, 0.1, 0.1, 0.1]</p>
<p>  在权值分布D1的情况下，取已知的三个弱分类器h1、h2和h3中误差率最小的分类器作为第1个基本分类器H1(x)（三个弱分类器的误差率都是0.3，那就取第1个吧）</p>
<p><img src="http://120.25.221.136/images/adsboost/ada11.jpg" alt=""></p>
<p>  在分类器H1(x)=h1情况下，样本点“5 7 8”被错分，因此基本分类器H1(x)的误差率为：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost13.jpg" alt=""></p>
<p>  可见，被误分类样本的权值之和影响误差率e，误差率e影响基本分类器在最终分类器中所占的权重α。</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost14.jpg" alt=""></p>
<p>  然后，更新训练样本数据的权值分布，用于下一轮迭代，对于正确分类的训练样本“1 2 3 4 6 9 10”（共7个）的权值更新为：<img src="http://120.25.221.136/images/adsboost/adaboost15.jpg" alt=""></p>
<p>  这样，第1轮迭代后，最后得到各个样本数据新的权值分布：</p>
<p>D2=[1/14,1/14,1/14,1/14,1/6,1/14,1/6,1/6,1/14,1/14]</p>
<p>由于样本数据“5 7 8”被H1(x)分错了，所以它们的权值由之前的0.1增大到1/6；反之，其它数据皆被分正确，所以它们的权值皆由之前的0.1减小到1/14，下表给出了权值分布的变换情况：</p>
<p>​    可得分类函数：f1(x)= α1H1(x) = 0.4236H1(x)。此时，组合一个基本分类器sign(f1(x))作为强分类器在训练数据集上有3个误分类点（即5 7 8），此时强分类器的训练错误为：0.3</p>
<p>第二次迭代t=2：</p>
<p>  在权值分布D2的情况下，再取三个弱分类器h1、h2和h3中误差率最小的分类器作为第2个基本分类器H2(x)：①　当取弱分类器h1=X1=2.5时，此时被错分的样本点为“5 7 8”：误差率e=1/6+1/6+1/6=3/6=1/2；</p>
<p>②　当取弱分类器h2=X1=8.5时，此时被错分的样本点为“3 4 6”：误差率e=1/14+1/14+1/14=3/14；③　当取弱分类器h3=X2=6.5时，此时被错分的样本点为“1 2 9”：误差率e=1/14+1/14+1/14=3/14；   因此，取当前最小的分类器h2作为第2个基本分类器H2(x)：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost17.jpg" alt=""></p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost18.jpg" alt=""></p>
<p>​    显然，H2(x)把样本“3 4 6”分错了，根据D2可知它们的权值为D2(3)=1/14，D2(4)=1/14， D2(6)=1/14，所以H2(x)在训练数据集上的误差率：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost19.jpg" alt=""></p>
<p>  这样，第2轮迭代后，最后得到各个样本数据新的权值分布：</p>
<p>D3=[1/22,1/22,1/6,1/6,7/66,1/6,7/66,7/66,1/22,1/22]</p>
<p>  下表给出了权值分布的变换情况：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost20.jpg" alt=""></p>
<p>   可得分类函数：f2(x)=0.4236H1(x) + 0.6496H2(x)。此时，组合两个基本分类器sign(f2(x))作为强分类器在训练数据集上有3个误分类点（即3 4 6），此时强分类器的训练错误为：0.3</p>
<p>第三次迭代t=3:</p>
<p>  在权值分布D3的情况下，再取三个弱分类器h1、h2和h3中误差率最小的分类器作为第3个基本分类器H3(x)：①　当取弱分类器h1=X1=2.5时，此时被错分的样本点为“5 7 8”：误差率e=7/66+7/66+7/66=7/22；</p>
<p>②　当取弱分类器h2=X1=8.5时，此时被错分的样本点为“3 4 6”：误差率e=1/6+1/6+1/6=1/2=0.5；</p>
<p>③　当取弱分类器h3=X2=6.5时，此时被错分的样本点为“1 2 9”：误差率e=1/22+1/22+1/22=3/22；</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost21.jpg" alt=""></p>
<p>   因此，取当前最小的分类器h3作为第3个基本分类器H3(x)：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost22.jpg" alt=""></p>
<p>  这样，第3轮迭代后，得到各个样本数据新的权值分布为：</p>
<p>D4=[1/6,1/6,11/114,11/114,7/114,11/114,7/114,7/114,1/6,1/38]</p>
<p>  下表给出了权值分布的变换情况：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost23.jpg" alt=""></p>
<p>​    可得分类函数：f3(x)=0.4236H1(x) + 0.6496H2(x)+0.9229H3(x)。此时，组合三个基本分类器sign(f3(x))作为强分类器，在训练数据集上有0个误分类点。至此，整个训练过程结束。</p>
<p>  整合所有分类器，可得最终的强分类器为：</p>
<p><img src="http://120.25.221.136/images/adsboost/adaboost24.jpg" alt=""></p>
<p><strong>这个强分类器Hfinal对训练样本的错误率为0！</strong></p>
<h3 id="AdaBoost的优点和缺点"><a href="#AdaBoost的优点和缺点" class="headerlink" title="AdaBoost的优点和缺点"></a>AdaBoost的优点和缺点</h3><p><strong>优点</strong></p>
<p>​     （1）Adaboost提供一种框架，在框架内可以使用各种方法构建子分类器。可以使用简单的弱分类器，不用对特征进行筛选，也<strong>不存在过拟合的现象</strong>。<strong>(低偏差低方差)</strong></p>
<p>​     （2）Adaboost算法不需要弱分类器的先验知识，最后得到的强分类器的分类精度依赖于所有弱分类器。无论是应用于人造数据还是真实数据，Adaboost都能显著的提高学习精度。</p>
<p>​     （3）Adaboost算法不需要预先知道弱分类器的错误率上限，且最后得到的强分类器的分类精度依赖于所有弱分类器的分类精度，可以深挖分类器的能力。Adaboost可以根据弱分类器的反馈，自适应地调整假定的错误率，执行的效率高。</p>
<p>​     （4）Adaboost对同一个训练样本集训练不同的弱分类器，按照一定的方法把这些弱分类器集合起来，构造一个分类能力很强的强分类器，即“三个臭皮匠赛过一个诸葛亮”。</p>
<p><strong>缺点：</strong></p>
<p>​     在Adaboost训练过程中，Adaboost会使得难于分类样本的权值呈指数增长，训练将会过于偏向这类困难的样本，导致Adaboost算法易受噪声干扰。此外，Adaboost依赖于弱分类器，而弱分类器的训练时间往往很长。</p>
<p><strong>为什么AdaBoost不会过拟合？</strong></p>
<p>　　关于Adaboost，它是boosting算法，从bias-variance（偏差-方差）的角度来看，boosting算法主要关注的是降低偏差</p>
<p>　　而boosting算法每个分类器都是弱分类器，而弱分类器的特性就是high-bias &amp; low variance（高偏差-低方差），其与生俱来的优点就是泛化性能好</p>
<p>　　因此，将多个算法组合起来之后，可以达到降偏差的效果，进而得到一个偏差小、方差小的泛化能力好的模型。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/04/HIVE自定义函数之UDF，UDAF和UDTF区别/" title="HIVE自定义函数之UDF，UDAF和UDTF区别" itemprop="url">HIVE自定义函数之UDF，UDAF和UDTF区别</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-04T12:50:58.035Z" itemprop="datePublished"> 发表于 2018-07-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p> <strong>(1)udf(user defined function)：  自定义函数，特点是输入一行，输出一行</strong></p>
<p>  <strong>(2)udaf(user defined aggregation function)：自定义聚合函数，特点是输入多行，输出一行</strong></p>
<p>  <strong>(3)udtf(User-Defined Table-Generating Functions):自定义拆分函数，特点是输入一行，输出多行</strong></p>
<p>2、使用</p>
<p>​    (1)UDF开发和使用步骤</p>
<p>​       创建函数流程<br>a、自定义一个Java类<br>b、继承UDF类<br>c、重写evaluate方法<br>d、打成jar包<br>e、在hive执行add jar方法 (临时使用)<br>f、在hive执行创建模板函数<br>g、hql中使用</p>
<p>   (2)UDAF开发和使用步骤   </p>
<p>​           a、顶层UDAF类继承<br>            org.apache.hadoop.hive.ql.udf.generic.GenericUDAFEvaluator里面编写嵌套类evaluator实现UDAF的逻辑。</p>
<p>​           b、实现resolver :resolver负责类型检查，操作符重载<br>                 resolver通常继承<br>                 org.apache.hadoop.hive.ql.udf.GenericUDAFResolver2，但是更建议继承AbstractGenericUDAFResolver，</p>
<p>​                  隔离将来hive接口的变化。<br>                 GenericUDAFResolver和GenericUDAFResolver2接口的区别是后面的允许evaluator实现可以访问更多的信息，</p>
<p>​                 例如DISTINCT限定符，通配符FUNCTION(*)。</p>
<p>​           c、实现evaluator :evaluator真正实现UDAF的逻辑<br>                 所有evaluators必须继承抽象类<br>                 org.apache.hadoop.hive.ql.udf.generic.GenericUDAFEvaluator。予类必须实现它的一些抽象方法，</p>
<p>​                 实现UDAF的逻辑。</p>
<p>​           d、打成jar包<br>   e、在hive执行add jar方法 (临时使用)<br>   f、在hive执行创建模板函数<br>   g、hql中使用</p>
<p>​       (3)UDTF开发和使用</p>
<p>​         a、 继承org.apache.hadoop.hive.ql.udf.generic.GenericUDTF,实现initialize, process, close三个方法。</p>
<p>  b、UDTF首先会调用initialize方法，此方法返回UDTF的返回行的信息（返回个数，类型）。</p>
<p>  c、初始化完成后，会调用process方法,真正的处理过程在process函数中，在process中，每一次forward()调用产生一行；</p>
<p>​       如果产生多列可以将多个列的值放在一个数组中，然后将该数组传入到forward()函数。</p>
<p>​      最后close()方法调用，对需要清理的方法进行清理。</p>
<p>  d、打成jar包 </p>
<p>  e、在hive执行add jar方法 (临时使用)</p>
<p>  f、在hive执行创建模板函数 </p>
<p>  g、hql中使用</p>
<p>​     注意：UDTF有两种使用方法，一种直接放到select后面，一种和lateral view一起使用。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/04/hive 复合结构Map、Struct/" title="hive 复合结构Map、Struct(转)" itemprop="url">hive 复合结构Map、Struct(转)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-04T07:37:08.038Z" itemprop="datePublished"> 发表于 2018-07-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Map详解</p>
<p>hive里支持map的结构如下：</p>
<p>(key1, value1, key2, value2, …) Creates a map with the given key/value pairs</p>
<p>建表语句：</p>
<p>create table test_map(name string, score map<string,int>)</string,int></p>
<p>ROW FORMAT DELIMITED</p>
<p>FIELDS TERMINATED BY ‘\t’</p>
<p>COLLECTION ITEMS TERMINATED BY ‘,’</p>
<p>MAP KEYS TERMINATED BY ‘:’</p>
<p>测试数据</p>
<p>cat test</p>
<p>leilei 数学:99,语文:90,英语:96</p>
<p>lucy 数学:100,语文:85,英语:91</p>
<p>将数据导入表中：</p>
<p>LOAD DATA LOCAL INPATH ‘/home/webopa/lei.wang/datas_test/test_map’ OVERWRITE INTO TABLE test_map;</p>
<p>在表中查询：</p>
<p>hive&gt; select * from test_map;</p>
<p>OK</p>
<p>leilei {“数学”:99,”语文”:90,”英语”:96}</p>
<p>lucy {“数学”:100,”语文”:85,”英语”:91}</p>
<p>Time taken: 0.052 seconds, Fetched: 2 row(s)</p>
<p>hive&gt; select ts.name,ts.score[‘数学’] from test_map ts;</p>
<p>Total jobs = 1</p>
<p>Launching Job 1 out of 1</p>
<p>…</p>
<p>Total MapReduce CPU Time Spent: 3 seconds 280 msec</p>
<p>OK</p>
<p>leilei 99</p>
<p>lucy 100</p>
<p>Time taken: 26.072 seconds, Fetched: 2 row(s)</p>
<p>Struct</p>
<p>hive里支持的Struct结构：</p>
<p>(val1, val2, val3, …) Creates a struct with the given field values. Struct field names will be col1, col2, …</p>
<p>建表语句</p>
<p>CREATE TABLE test_struct(name string,lable struct<price:string,pay:string,num:int>)</price:string,pay:string,num:int></p>
<p>ROW FORMAT DELIMITED</p>
<p>FIELDS TERMINATED BY ‘\t’</p>
<p>COLLECTION ITEMS TERMINATED BY ‘,’</p>
<p>测试数据</p>
<p>cat test_struct</p>
<p>aaa cheap,imm,1</p>
<p>bbb high,imm,2</p>
<p>将数据导入表中</p>
<p>LOAD DATA LOCAL INPATH ‘/home/webopa/lei.wang/datas_test/test_struct’ OVERWRITE INTO TABLE test_struct</p>
<p>在表中查询</p>
<p>hive&gt; select * from test_struct;</p>
<p>OK</p>
<p>aaa {“price”:”cheap”,”pay”:”imm”,”num”:1}</p>
<p>bbb {“price”:”high”,”pay”:”imm”,”num”:2}</p>
<p>Time taken: 0.046 seconds, Fetched: 2 row(s)</p>
<p>hive&gt; select name,lable.price from test_struct;</p>
<p>Total jobs = 1</p>
<p>Launching Job 1 out of 1</p>
<p>…</p>
<p>Total MapReduce CPU Time Spent: 1 seconds 270 msec</p>
<p>OK</p>
<p>aaa cheap</p>
<p>bbb high</p>
<p>Time taken: 20.054 seconds, Fetched: 2 row(s)</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/03/处理数据中的缺失值/" title="处理数据中的缺失值" itemprop="url">处理数据中的缺失值</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-03T02:12:53.412Z" itemprop="datePublished"> 发表于 2018-07-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="缺失值产生的原因"><a href="#缺失值产生的原因" class="headerlink" title="缺失值产生的原因"></a>缺失值产生的原因</h3><p>缺失值的产生的原因多种多样，主要分为机械原因和人为原因。</p>
<ul>
<li>机械原因是由于机械原因导致的数据收集或保存的失败造成的数据缺失，比如数据存储的失败，存储器损坏，机械故障导致某段时间数据未能收集（对于定时数据采集而言）。</li>
<li>人为原因是由于人的主观失误、历史局限或有意隐瞒造成的数据缺失，比如，在市场调查中被访人拒绝透露相关问题的答案，或者回答的问题是无效的，数据录入人员失误漏录了数据。 </li>
</ul>
<h3 id="处理缺失值的方法"><a href="#处理缺失值的方法" class="headerlink" title="处理缺失值的方法"></a>处理缺失值的方法</h3><p><strong>使用可用特征的均值来填补缺失值；</strong><br><strong> 使用特殊值来填补缺失值，如-1；</strong><br><strong> 忽略有缺失值的样本；</strong><br><strong> 使用相似样本的均值添补缺失值；</strong><br><strong> 使用另外的机器学习算法预测缺失值。</strong></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/21/sql面试题集锦/" title="SQL面试题集锦" itemprop="url">SQL面试题集锦</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-21T12:32:58.331Z" itemprop="datePublished"> 发表于 2018-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="1-有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。"><a href="#1-有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。" class="headerlink" title="1.有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。"></a>1.有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。</h4><p>A 学生表(student)<br>字段1 学生号(sid)<br>字段2 学生名(sname)</p>
<p>B 科目表(course)<br>字段1 科目号(cid)<br>字段2 科目名(cname)</p>
<p>C 成绩表(grade)<br>字段1 成绩号(gid)<br>字段2 学生号(sid)<br>字段3 科目号(cid)<br>字段4 成绩(score)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line"><span class="string">`sid`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`sname`</span>  <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`sid`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci</span><br><span class="line">ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cname ,t.sid <span class="keyword">from</span> grade <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span>  (<span class="keyword">SELECT</span> * <span class="keyword">from</span>  student ,course)<span class="keyword">as</span> t <span class="keyword">on</span> grade.cid=t.cid <span class="keyword">and</span> grade.sid=t.sid <span class="keyword">where</span> grade.score <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h4 id="2-有如下表："><a href="#2-有如下表：" class="headerlink" title="2.有如下表："></a>2.有如下表：</h4><table>
<thead>
<tr>
<th>日期(time)</th>
<th>结果(result)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2005-05-09</td>
<td>胜</td>
</tr>
<tr>
<td>2005-05-09</td>
<td>胜</td>
</tr>
<tr>
<td>2005-05-09</td>
<td>负</td>
</tr>
<tr>
<td>2005-05-09</td>
<td>负</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>胜</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>负</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>负</td>
</tr>
</tbody>
</table>
<p>如果要生成下列结果，该如何写sql语句？</p>
<table>
<thead>
<tr>
<th>日期</th>
<th>胜</th>
<th>负</th>
</tr>
</thead>
<tbody>
<tr>
<td>2005-05-09</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`game`</span> (</span><br><span class="line"><span class="string">`time`</span>  <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`result`</span>  <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci</span><br><span class="line">ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">time</span> ,<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">result</span> <span class="keyword">when</span> <span class="string">'胜'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">end</span> ) <span class="keyword">as</span> 胜,<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">result</span> <span class="keyword">when</span> <span class="string">'负'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">end</span> ) <span class="keyword">as</span> 负 <span class="keyword">from</span> game <span class="keyword">GROUP</span> <span class="keyword">BY</span> game.time</span><br></pre></td></tr></table></figure>
<h4 id="3-原表："><a href="#3-原表：" class="headerlink" title="3.原表："></a>3.原表：</h4><table>
<thead>
<tr>
<th style="text-align:center">gid</th>
<th style="text-align:center">sid</th>
<th style="text-align:center">cid</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">60</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">99</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">57</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">78</td>
</tr>
</tbody>
</table>
<p>为了方便阅读，查询此表后的显示结果如下（及格分数为60分）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">gid</th>
<th style="text-align:center">sid</th>
<th style="text-align:center">cid</th>
<th style="text-align:center">score</th>
<th style="text-align:center">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">60</td>
<td style="text-align:center">pass</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">90</td>
<td style="text-align:center">pass</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">99</td>
<td style="text-align:center">pass</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">57</td>
<td style="text-align:center">failed</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">58</td>
<td style="text-align:center">failed</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`garde`</span> (</span><br><span class="line"><span class="string">`gid`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`sid`</span>  <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`cid`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`score`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`gid`</span>))</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci</span><br><span class="line">ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,</span><br><span class="line"> <span class="keyword">case</span>  <span class="keyword">when</span> score &gt;<span class="string">'60'</span> <span class="keyword">then</span> <span class="string">'pass'</span> <span class="keyword">ELSE</span> <span class="string">"failed"</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> <span class="string">"mark"</span></span><br><span class="line"><span class="keyword">from</span> grade</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>,gid <span class="keyword">from</span>  grade  <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span>  <span class="keyword">HAVING</span>  <span class="keyword">count</span>(<span class="keyword">sid</span>)=(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">from</span> course)</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/19/交叉验证的原因/" title="交叉验证" itemprop="url">交叉验证</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-19T12:32:46.224Z" itemprop="datePublished"> 发表于 2018-06-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>训练过程中模型在训练集表现的很好，但在训练数据外的话对数据的拟合程度并不高，造成过拟合现象。素银使用交叉验证评估模型的预测能力，在一定的程度上减少过拟合，拥有更好的泛化能力。</li>
<li>在有限的数据中尽可能的获取更多的有效信息。</li>
</ul>
<h3 id="交叉验证的思想"><a href="#交叉验证的思想" class="headerlink" title="交叉验证的思想"></a>交叉验证的思想</h3><p>将原始数据进行分组，一部分作为训练集一部分作为测试集，首先用训练集对模型进行训练,再利用验证集来测试模型的泛化误差。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>留出法</p>
<p>在机器学习任务中，拿到数据后，我们首先会将原始数据集分为三部分：<strong>训练集、验证集和测试集</strong>。<br>训练集用于训练模型，验证集用于模型的参数选择配置，测试集对于模型来说是未知数据，用于评估模型的泛化能力。</p>
</li>
</ul>
<ul>
<li>k 折交叉验证（k-fold cross validation）</li>
</ul>
<p>​        k 折交叉验证通过对 k 个不同分组训练的结果进行平均来减少方差，因此模型的性能对数据的划分就不那么敏感。</p>
<ul>
<li>第一步，不重复抽样将原始数据随机分为 k 份。</li>
<li>第二步，每一次挑选其中 1 份作为测试集，剩余 k-1 份作为训练集用于模型训练。</li>
<li>第三步，重复第二步 k 次，这样每个子集都有一次机会作为测试集，其余机会作为训练集。</li>
<li>在每个训练集上训练后得到一个模型，</li>
<li>用这个模型在相应的测试集上测试，计算并保存模型的评估指标，</li>
<li>第四步，计算 k 组测试结果的平均值作为模型精度的估计，并作为当前 k 折交叉验证下模型的性能指标。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/19/MapReduce详解Shuffle(copy,sort,merge)过程/" title="MapReduce:详解Shuffle(copy,sort,merge)过程(转)" itemprop="url">MapReduce:详解Shuffle(copy,sort,merge)过程(转)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-19T11:23:28.266Z" itemprop="datePublished"> 发表于 2018-06-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Shuffle过程是MapReduce的核心，也被称为奇迹发生的地方。要想理解MapReduce， Shuffle是必须要了解的。我看过很多相关的资料，但每次看完都云里雾里的绕着，很难理清大致的逻辑，反而越搅越混。前段时间在做MapReduce job 性能调优的工作，需要深入代码研究MapReduce的运行机制，这才对Shuffle探了个究竟。考虑到之前我在看相关资料而看不懂时很恼火，所以在这里我尽最大的可能试着把Shuffle说清楚，让每一位想了解它原理的朋友都能有所收获。如果你对这篇文章有任何疑问或建议请留言到后面，谢谢！ </p>
<p>​        Shuffle的正常意思是洗牌或弄乱，可能大家更熟悉的是Java API里的Collections.shuffle(List)方法，它会随机地打乱参数list里的元素顺序。如果你不知道MapReduce里Shuffle是什么，那么请看这张图：</p>
<p><img src="http://dl.iteye.com/upload/attachment/456531/4df193f5-e56e-308f-9689-eac035dd8a2b.png" alt="img"></p>
<p>这张是官方对Shuffle过程的描述。但我可以肯定的是，单从这张图你基本不可能明白Shuffle的过程，因为它与事实相差挺多，细节也是错乱的。后面我会具体描述Shuffle的事实情况，所以这里你只要清楚Shuffle的大致范围就成－怎样把map task的输出结果有效地传送到reduce端。也可以这样理解， Shuffle描述着数据从map task输出到reduce task输入的这段过程。 </p>
<p>​        在Hadoop这样的集群环境中，大部分map task与reduce task的执行是在不同的节点上。当然很多情况下Reduce执行时需要跨节点去拉取其它节点上的map task结果。如果集群正在运行的job有很多，那么task的正常执行对集群内部的网络资源消耗会很严重。这种网络消耗是正常的，我们不能限制，能做的就是最大化地减少不必要的消耗。还有在节点内，相比于内存，磁盘IO对job完成时间的影响也是可观的。从最基本的要求来说，我们对Shuffle过程的期望可以有： </p>
<ul>
<li>完整地从map task端拉取数据到reduce 端。</li>
<li>在跨节点拉取数据时，尽可能地减少对带宽的不必要消耗。</li>
<li>减少磁盘IO对task执行的影响。</li>
</ul>
<p>​        OK，看到这里时，大家可以先停下来想想，如果是自己来设计这段Shuffle过程，那么你的设计目标是什么。我想能优化的地方主要在于减少拉取数据的量及尽量使用内存而不是磁盘。 </p>
<p>​        我的分析是基于Hadoop0.21.0的源码，如果与你所认识的Shuffle过程有差别，不吝指出。我会以WordCount为例，并假设它有8个map task和3个reduce task。从上图看出，Shuffle过程横跨map与reduce两端，所以下面我也会分两部分来展开。 </p>
<p>​        先看看map端的情况，如下图：</p>
<p><img src="http://dl.iteye.com/upload/attachment/456529/641c4f01-6c9d-322c-b428-9981866d86a6.jpg" alt="img"></p>
<p>​        上图可能是某个map task的运行情况。拿它与官方图的左半边比较，会发现很多不一致。官方图没有清楚地说明partition， sort与combiner到底作用在哪个阶段。我画了这张图，希望让大家清晰地了解从map数据输入到map端所有数据准备好的全过程。 </p>
<p>​        整个流程我分了四步。简单些可以这样说，每个map task都有一个内存缓冲区，存储着map的输出结果，当缓冲区快满的时候需要将缓冲区的数据以一个临时文件的方式存放到磁盘，当整个map task结束后再对磁盘中这个map task产生的所有临时文件做合并，生成最终的正式输出文件，然后等待reduce task来拉数据。 </p>
<p>​        当然这里的每一步都可能包含着多个步骤与细节，下面我对细节来一一说明： </p>
<ol>
<li><p>在map task执行时，它的输入数据来源于HDFS的block，当然在MapReduce概念中，map task只读取split。Split与block的对应关系可能是多对一，默认是一对一。在WordCount例子里，假设map的输入数据都是像“aaa”这样的字符串。 </p>
</li>
<li><p>在经过mapper的运行后，我们得知mapper的输出是这样一个key/value对： key是“aaa”， value是数值1。因为当前map端只做加1的操作，在reduce task里才去合并结果集。前面我们知道这个job有3个reduce task，到底当前的“aaa”应该交由哪个reduce去做呢，是需要现在决定的。 </p>
</li>
</ol>
<p>​        MapReduce提供Partitioner接口，它的作用就是根据key或value及reduce的数量来决定当前的这对输出数据最终应该交由哪个reduce task处理。默认对key hash后再以reduce task数量取模。默认的取模方式只是为了平均reduce的处理能力，如果用户自己对Partitioner有需求，可以订制并设置到job上。 </p>
<p>​        在我们的例子中，“aaa”经过Partitioner后返回0，也就是这对值应当交由第一个reducer来处理。接下来，需要将数据写入内存缓冲区中，缓冲区的作用是批量收集map结果，减少磁盘IO的影响。我们的key/value对以及Partition的结果都会被写入缓冲区。当然写入之前，key与value值都会被序列化成字节数组。 </p>
<p>​        整个内存缓冲区就是一个字节数组，它的字节索引及key/value存储结构我没有研究过。如果有朋友对它有研究，那么请大致描述下它的细节吧。 </p>
<ol>
<li>这个内存缓冲区是有大小限制的，默认是100MB。当map task的输出结果很多时，就可能会撑爆内存，所以需要在一定条件下将缓冲区中的数据临时写入磁盘，然后重新利用这块缓冲区。这个从内存往磁盘写数据的过程被称为Spill，中文可译为溢写，字面意思很直观。这个溢写是由单独线程来完成，不影响往缓冲区写map结果的线程。溢写线程启动时不应该阻止map的结果输出，所以整个缓冲区有个溢写的比例spill.percent。这个比例默认是0.8，也就是当缓冲区的数据已经达到阈值（buffer size <em> spill percent = 100MB </em> 0.8 = 80MB），溢写线程启动，锁定这80MB的内存，执行溢写过程。Map task的输出结果还可以往剩下的20MB内存中写，互不影响。 </li>
</ol>
<p>​        当溢写线程启动后，需要对这80MB空间内的key做排序(Sort)。排序是MapReduce模型默认的行为，这里的排序也是对序列化的字节做的排序。 </p>
<p>​        在这里我们可以想想，因为map task的输出是需要发送到不同的reduce端去，而内存缓冲区没有对将发送到相同reduce端的数据做合并，那么这种合并应该是体现是磁盘文件中的。从官方图上也可以看到写到磁盘中的溢写文件是对不同的reduce端的数值做过合并。所以溢写过程一个很重要的细节在于，如果有很多个key/value对需要发送到某个reduce端去，那么需要将这些key/value值拼接到一块，减少与partition相关的索引记录。 </p>
<p>​        在针对每个reduce端而合并数据时，有些数据可能像这样：“aaa”/1， “aaa”/1。对于WordCount例子，就是简单地统计单词出现的次数，如果在同一个map task的结果中有很多个像“aaa”一样出现多次的key，我们就应该把它们的值合并到一块，这个过程叫reduce也叫combine。但MapReduce的术语中，reduce只指reduce端执行从多个map task取数据做计算的过程。除reduce外，非正式地合并数据只能算做combine了。其实大家知道的，MapReduce中将Combiner等同于Reducer。 </p>
<p>​        如果client设置过Combiner，那么现在就是使用Combiner的时候了。将有相同key的key/value对的value加起来，减少溢写到磁盘的数据量。Combiner会优化MapReduce的中间结果，所以它在整个模型中会多次使用。那哪些场景才能使用Combiner呢？从这里分析，Combiner的输出是Reducer的输入，Combiner绝不能改变最终的计算结果。所以从我的想法来看，Combiner只应该用于那种Reduce的输入key/value与输出key/value类型完全一致，且不影响最终结果的场景。比如累加，最大值等。Combiner的使用一定得慎重，如果用好，它对job执行效率有帮助，反之会影响reduce的最终结果。 </p>
<ol>
<li>每次溢写会在磁盘上生成一个溢写文件，如果map的输出结果真的很大，有多次这样的溢写发生，磁盘上相应的就会有多个溢写文件存在。当map task真正完成时，内存缓冲区中的数据也全部溢写到磁盘中形成一个溢写文件。最终磁盘中会至少有一个这样的溢写文件存在(如果map的输出结果很少，当map执行完成时，只会产生一个溢写文件)，因为最终的文件只有一个，所以需要将这些溢写文件归并到一起，这个过程就叫做Merge。Merge是怎样的？如前面的例子，“aaa”从某个map task读取过来时值是5，从另外一个map 读取时值是8，因为它们有相同的key，所以得merge成group。什么是group。对于“aaa”就是像这样的：{“aaa”, [5, 8, 2, …]}，数组中的值就是从不同溢写文件中读取出来的，然后再把这些值加起来。请注意，因为merge是将多个溢写文件合并到一个文件，所以可能也有相同的key存在，在这个过程中如果client设置过Combiner，也会使用Combiner来合并相同的key。 </li>
</ol>
<p>​        至此，map端的所有工作都已结束，最终生成的这个文件也存放在TaskTracker够得着的某个本地目录内。每个reduce task不断地通过RPC从JobTracker那里获取map task是否完成的信息，如果reduce task得到通知，获知某台TaskTracker上的map task执行完成，Shuffle的后半段过程开始启动。 </p>
<p>​        简单地说，reduce task在执行之前的工作就是不断地拉取当前job里每个map task的最终结果，然后对从不同地方拉取过来的数据不断地做merge，也最终形成一个文件作为reduce task的输入文件。见下图：</p>
<p><img src="http://dl.iteye.com/upload/attachment/456527/608c7e08-896d-3697-a57e-a8ca60cf79ea.jpg" alt="img"></p>
<p>​        如map 端的细节图，Shuffle在reduce端的过程也能用图上标明的三点来概括。当前reduce copy数据的前提是它要从JobTracker获得有哪些map task已执行结束，这段过程不表，有兴趣的朋友可以关注下。Reducer真正运行之前，所有的时间都是在拉取数据，做merge，且不断重复地在做。如前面的方式一样，下面我也分段地描述reduce 端的Shuffle细节： </p>
<ol>
<li><p>Copy过程，简单地拉取数据。Reduce进程启动一些数据copy线程(Fetcher)，通过HTTP方式请求map task所在的TaskTracker获取map task的输出文件。因为map task早已结束，这些文件就归TaskTracker管理在本地磁盘中。 </p>
</li>
<li><p>Merge阶段。这里的merge如map端的merge动作，只是数组中存放的是不同map端copy来的数值。Copy过来的数据会先放入内存缓冲区中，这里的缓冲区大小要比map端的更为灵活，它基于JVM的heap size设置，因为Shuffle阶段Reducer不运行，所以应该把绝大部分的内存都给Shuffle用。这里需要强调的是，merge有三种形式：1)内存到内存  2)内存到磁盘  3)磁盘到磁盘。默认情况下第一种形式不启用，让人比较困惑，是吧。当内存中的数据量到达一定阈值，就启动内存到磁盘的merge。与map 端类似，这也是溢写的过程，这个过程中如果你设置有Combiner，也是会启用的，然后在磁盘中生成了众多的溢写文件。第二种merge方式一直在运行，直到没有map端的数据时才结束，然后启动第三种磁盘到磁盘的merge方式生成最终的那个文件。 </p>
</li>
<li><p>Reducer的输入文件。不断地merge后，最后会生成一个“最终文件”。为什么加引号？因为这个文件可能存在于磁盘上，也可能存在于内存中。对我们来说，当然希望它存放于内存中，直接作为Reducer的输入，但默认情况下，这个文件是存放于磁盘中的。至于怎样才能让这个文件出现在内存中，之后的<a href="http://langyu.iteye.com/blog/1341267" target="_blank" rel="noopener">性能优化篇</a>我再说。当Reducer的输入文件已定，整个Shuffle才最终结束。然后就是Reducer执行，把结果放到HDFS上。 </p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="https://github.com/pengyuanqiuqiu" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>



  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.nowcoder.com/" target="_blank" title="牛客网">牛客网</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.acmcoder.com/index" target="_blank" title="赛码网">赛码网</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="http://www.163.com/rss/" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="400" class="share_self"  frameborder="0" scrolling="no" src="https://widget.weibo.com/weiboshow/index.php?language=&width=0&height=400&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=2871001534&verifier=2889e96f&colors=d6f3f7,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m jianyu. <br/>
			Let&#39;s go!</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2871001534" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/pengyuanqiuqiu" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/peng-yuan-19-57?utm_source=qq&amp;utm_medium=social" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:987219258@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by © 2018 
		
		<a href="https://pengyuanqiuqiu.github.io/" target="_blank" title="PengYuan">PengYuan</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
