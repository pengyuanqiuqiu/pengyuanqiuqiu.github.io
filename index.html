
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Jianyu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="PengYuan">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Jianyu">
<meta property="og:url" content="https://pengyuanqiuqiu.github.io/index.html">
<meta property="og:site_name" content="Jianyu">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jianyu">

    
    <link rel="alternative" href="http://www.163.com/rss/" title="Jianyu" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Jianyu" title="Jianyu"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Jianyu">Jianyu</a></h1>
				<h2 class="blog-motto">Learn more and more</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:pengyuanqiuqiu.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/04/hive 复合结构Map、Struct/" title="hive 复合结构Map、Struct(转)" itemprop="url">hive 复合结构Map、Struct(转)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-04T07:37:08.038Z" itemprop="datePublished"> 发表于 2018-07-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Map详解</p>
<p>hive里支持map的结构如下：</p>
<p>(key1, value1, key2, value2, …) Creates a map with the given key/value pairs</p>
<p>建表语句：</p>
<p>create table test_map(name string, score map<string,int>)</string,int></p>
<p>ROW FORMAT DELIMITED</p>
<p>FIELDS TERMINATED BY ‘\t’</p>
<p>COLLECTION ITEMS TERMINATED BY ‘,’</p>
<p>MAP KEYS TERMINATED BY ‘:’</p>
<p>测试数据</p>
<p>cat test</p>
<p>leilei 数学:99,语文:90,英语:96</p>
<p>lucy 数学:100,语文:85,英语:91</p>
<p>将数据导入表中：</p>
<p>LOAD DATA LOCAL INPATH ‘/home/webopa/lei.wang/datas_test/test_map’ OVERWRITE INTO TABLE test_map;</p>
<p>在表中查询：</p>
<p>hive&gt; select * from test_map;</p>
<p>OK</p>
<p>leilei {“数学”:99,”语文”:90,”英语”:96}</p>
<p>lucy {“数学”:100,”语文”:85,”英语”:91}</p>
<p>Time taken: 0.052 seconds, Fetched: 2 row(s)</p>
<p>hive&gt; select ts.name,ts.score[‘数学’] from test_map ts;</p>
<p>Total jobs = 1</p>
<p>Launching Job 1 out of 1</p>
<p>…</p>
<p>Total MapReduce CPU Time Spent: 3 seconds 280 msec</p>
<p>OK</p>
<p>leilei 99</p>
<p>lucy 100</p>
<p>Time taken: 26.072 seconds, Fetched: 2 row(s)</p>
<p>Struct</p>
<p>hive里支持的Struct结构：</p>
<p>(val1, val2, val3, …) Creates a struct with the given field values. Struct field names will be col1, col2, …</p>
<p>建表语句</p>
<p>CREATE TABLE test_struct(name string,lable struct<price:string,pay:string,num:int>)</price:string,pay:string,num:int></p>
<p>ROW FORMAT DELIMITED</p>
<p>FIELDS TERMINATED BY ‘\t’</p>
<p>COLLECTION ITEMS TERMINATED BY ‘,’</p>
<p>测试数据</p>
<p>cat test_struct</p>
<p>aaa cheap,imm,1</p>
<p>bbb high,imm,2</p>
<p>将数据导入表中</p>
<p>LOAD DATA LOCAL INPATH ‘/home/webopa/lei.wang/datas_test/test_struct’ OVERWRITE INTO TABLE test_struct</p>
<p>在表中查询</p>
<p>hive&gt; select * from test_struct;</p>
<p>OK</p>
<p>aaa {“price”:”cheap”,”pay”:”imm”,”num”:1}</p>
<p>bbb {“price”:”high”,”pay”:”imm”,”num”:2}</p>
<p>Time taken: 0.046 seconds, Fetched: 2 row(s)</p>
<p>hive&gt; select name,lable.price from test_struct;</p>
<p>Total jobs = 1</p>
<p>Launching Job 1 out of 1</p>
<p>…</p>
<p>Total MapReduce CPU Time Spent: 1 seconds 270 msec</p>
<p>OK</p>
<p>aaa cheap</p>
<p>bbb high</p>
<p>Time taken: 20.054 seconds, Fetched: 2 row(s)</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/03/处理数据中的缺失值/" title="处理数据中的缺失值" itemprop="url">处理数据中的缺失值</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-07-03T02:12:53.412Z" itemprop="datePublished"> 发表于 2018-07-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="缺失值产生的原因"><a href="#缺失值产生的原因" class="headerlink" title="缺失值产生的原因"></a>缺失值产生的原因</h3><p>缺失值的产生的原因多种多样，主要分为机械原因和人为原因。</p>
<ul>
<li>机械原因是由于机械原因导致的数据收集或保存的失败造成的数据缺失，比如数据存储的失败，存储器损坏，机械故障导致某段时间数据未能收集（对于定时数据采集而言）。</li>
<li>人为原因是由于人的主观失误、历史局限或有意隐瞒造成的数据缺失，比如，在市场调查中被访人拒绝透露相关问题的答案，或者回答的问题是无效的，数据录入人员失误漏录了数据。 </li>
</ul>
<h3 id="处理缺失值的方法"><a href="#处理缺失值的方法" class="headerlink" title="处理缺失值的方法"></a>处理缺失值的方法</h3><p><strong>使用可用特征的均值来填补缺失值；</strong><br><strong> 使用特殊值来填补缺失值，如-1；</strong><br><strong> 忽略有缺失值的样本；</strong><br><strong> 使用相似样本的均值添补缺失值；</strong><br><strong> 使用另外的机器学习算法预测缺失值。</strong></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/21/sql面试题集锦/" title="SQL面试题集锦" itemprop="url">SQL面试题集锦</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-21T12:32:58.331Z" itemprop="datePublished"> 发表于 2018-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="1-有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。"><a href="#1-有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。" class="headerlink" title="1.有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。"></a>1.有三个表，如果学生缺考，那么在成绩表中就不存在这个学生的这门课程成绩的记录，写一段SQL语句，检索出每个学生缺考的科目。</h4><p>A 学生表(student)<br>字段1 学生号(sid)<br>字段2 学生名(sname)</p>
<p>B 科目表(course)<br>字段1 科目号(cid)<br>字段2 科目名(cname)</p>
<p>C 成绩表(grade)<br>字段1 成绩号(gid)<br>字段2 学生号(sid)<br>字段3 科目号(cid)<br>字段4 成绩(score)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line"><span class="string">`sid`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`sname`</span>  <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`sid`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci</span><br><span class="line">ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cname ,t.sid <span class="keyword">from</span> grade <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span>  (<span class="keyword">SELECT</span> * <span class="keyword">from</span>  student ,course)<span class="keyword">as</span> t <span class="keyword">on</span> grade.cid=t.cid <span class="keyword">and</span> grade.sid=t.sid <span class="keyword">where</span> grade.score <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h4 id="2-有如下表："><a href="#2-有如下表：" class="headerlink" title="2.有如下表："></a>2.有如下表：</h4><table>
<thead>
<tr>
<th>日期(time)</th>
<th>结果(result)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2005-05-09</td>
<td>胜</td>
</tr>
<tr>
<td>2005-05-09</td>
<td>胜</td>
</tr>
<tr>
<td>2005-05-09</td>
<td>负</td>
</tr>
<tr>
<td>2005-05-09</td>
<td>负</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>胜</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>负</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>负</td>
</tr>
</tbody>
</table>
<p>如果要生成下列结果，该如何写sql语句？</p>
<table>
<thead>
<tr>
<th>日期</th>
<th>胜</th>
<th>负</th>
</tr>
</thead>
<tbody>
<tr>
<td>2005-05-09</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>2005-05-10</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`game`</span> (</span><br><span class="line"><span class="string">`time`</span>  <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`result`</span>  <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci</span><br><span class="line">ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">time</span> ,<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">result</span> <span class="keyword">when</span> <span class="string">'胜'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">end</span> ) <span class="keyword">as</span> 胜,<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">result</span> <span class="keyword">when</span> <span class="string">'负'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">end</span> ) <span class="keyword">as</span> 负 <span class="keyword">from</span> game <span class="keyword">GROUP</span> <span class="keyword">BY</span> game.time</span><br></pre></td></tr></table></figure>
<h4 id="3-原表："><a href="#3-原表：" class="headerlink" title="3.原表："></a>3.原表：</h4><table>
<thead>
<tr>
<th style="text-align:center">gid</th>
<th style="text-align:center">sid</th>
<th style="text-align:center">cid</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">60</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">99</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">57</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">78</td>
</tr>
</tbody>
</table>
<p>为了方便阅读，查询此表后的显示结果如下（及格分数为60分）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">gid</th>
<th style="text-align:center">sid</th>
<th style="text-align:center">cid</th>
<th style="text-align:center">score</th>
<th style="text-align:center">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">60</td>
<td style="text-align:center">pass</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">90</td>
<td style="text-align:center">pass</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">99</td>
<td style="text-align:center">pass</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">57</td>
<td style="text-align:center">failed</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">58</td>
<td style="text-align:center">failed</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`garde`</span> (</span><br><span class="line"><span class="string">`gid`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`sid`</span>  <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`cid`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`score`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`gid`</span>))</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci</span><br><span class="line">ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,</span><br><span class="line"> <span class="keyword">case</span>  <span class="keyword">when</span> score &gt;<span class="string">'60'</span> <span class="keyword">then</span> <span class="string">'pass'</span> <span class="keyword">ELSE</span> <span class="string">"failed"</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> <span class="string">"mark"</span></span><br><span class="line"><span class="keyword">from</span> grade</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>,gid <span class="keyword">from</span>  grade  <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span>  <span class="keyword">HAVING</span>  <span class="keyword">count</span>(<span class="keyword">sid</span>)=(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">from</span> course)</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/19/交叉验证的原因/" title="交叉验证" itemprop="url">交叉验证</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-19T12:32:46.224Z" itemprop="datePublished"> 发表于 2018-06-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>训练过程中模型在训练集表现的很好，但在训练数据外的话对数据的拟合程度并不高，造成过拟合现象。素银使用交叉验证评估模型的预测能力，在一定的程度上减少过拟合，拥有更好的泛化能力。</li>
<li>在有限的数据中尽可能的获取更多的有效信息。</li>
</ul>
<h3 id="交叉验证的思想"><a href="#交叉验证的思想" class="headerlink" title="交叉验证的思想"></a>交叉验证的思想</h3><p>将原始数据进行分组，一部分作为训练集一部分作为测试集，首先用训练集对模型进行训练,再利用验证集来测试模型的泛化误差。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>留出法</p>
<p>在机器学习任务中，拿到数据后，我们首先会将原始数据集分为三部分：<strong>训练集、验证集和测试集</strong>。<br>训练集用于训练模型，验证集用于模型的参数选择配置，测试集对于模型来说是未知数据，用于评估模型的泛化能力。</p>
</li>
</ul>
<ul>
<li>k 折交叉验证（k-fold cross validation）</li>
</ul>
<p>​        k 折交叉验证通过对 k 个不同分组训练的结果进行平均来减少方差，因此模型的性能对数据的划分就不那么敏感。</p>
<ul>
<li>第一步，不重复抽样将原始数据随机分为 k 份。</li>
<li>第二步，每一次挑选其中 1 份作为测试集，剩余 k-1 份作为训练集用于模型训练。</li>
<li>第三步，重复第二步 k 次，这样每个子集都有一次机会作为测试集，其余机会作为训练集。</li>
<li>在每个训练集上训练后得到一个模型，</li>
<li>用这个模型在相应的测试集上测试，计算并保存模型的评估指标，</li>
<li>第四步，计算 k 组测试结果的平均值作为模型精度的估计，并作为当前 k 折交叉验证下模型的性能指标。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/19/MapReduce详解Shuffle(copy,sort,merge)过程/" title="MapReduce:详解Shuffle(copy,sort,merge)过程(转)" itemprop="url">MapReduce:详解Shuffle(copy,sort,merge)过程(转)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-19T11:23:28.266Z" itemprop="datePublished"> 发表于 2018-06-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Shuffle过程是MapReduce的核心，也被称为奇迹发生的地方。要想理解MapReduce， Shuffle是必须要了解的。我看过很多相关的资料，但每次看完都云里雾里的绕着，很难理清大致的逻辑，反而越搅越混。前段时间在做MapReduce job 性能调优的工作，需要深入代码研究MapReduce的运行机制，这才对Shuffle探了个究竟。考虑到之前我在看相关资料而看不懂时很恼火，所以在这里我尽最大的可能试着把Shuffle说清楚，让每一位想了解它原理的朋友都能有所收获。如果你对这篇文章有任何疑问或建议请留言到后面，谢谢！ </p>
<p>​        Shuffle的正常意思是洗牌或弄乱，可能大家更熟悉的是Java API里的Collections.shuffle(List)方法，它会随机地打乱参数list里的元素顺序。如果你不知道MapReduce里Shuffle是什么，那么请看这张图：</p>
<p><img src="http://dl.iteye.com/upload/attachment/456531/4df193f5-e56e-308f-9689-eac035dd8a2b.png" alt="img"></p>
<p>这张是官方对Shuffle过程的描述。但我可以肯定的是，单从这张图你基本不可能明白Shuffle的过程，因为它与事实相差挺多，细节也是错乱的。后面我会具体描述Shuffle的事实情况，所以这里你只要清楚Shuffle的大致范围就成－怎样把map task的输出结果有效地传送到reduce端。也可以这样理解， Shuffle描述着数据从map task输出到reduce task输入的这段过程。 </p>
<p>​        在Hadoop这样的集群环境中，大部分map task与reduce task的执行是在不同的节点上。当然很多情况下Reduce执行时需要跨节点去拉取其它节点上的map task结果。如果集群正在运行的job有很多，那么task的正常执行对集群内部的网络资源消耗会很严重。这种网络消耗是正常的，我们不能限制，能做的就是最大化地减少不必要的消耗。还有在节点内，相比于内存，磁盘IO对job完成时间的影响也是可观的。从最基本的要求来说，我们对Shuffle过程的期望可以有： </p>
<ul>
<li>完整地从map task端拉取数据到reduce 端。</li>
<li>在跨节点拉取数据时，尽可能地减少对带宽的不必要消耗。</li>
<li>减少磁盘IO对task执行的影响。</li>
</ul>
<p>​        OK，看到这里时，大家可以先停下来想想，如果是自己来设计这段Shuffle过程，那么你的设计目标是什么。我想能优化的地方主要在于减少拉取数据的量及尽量使用内存而不是磁盘。 </p>
<p>​        我的分析是基于Hadoop0.21.0的源码，如果与你所认识的Shuffle过程有差别，不吝指出。我会以WordCount为例，并假设它有8个map task和3个reduce task。从上图看出，Shuffle过程横跨map与reduce两端，所以下面我也会分两部分来展开。 </p>
<p>​        先看看map端的情况，如下图：</p>
<p><img src="http://dl.iteye.com/upload/attachment/456529/641c4f01-6c9d-322c-b428-9981866d86a6.jpg" alt="img"></p>
<p>​        上图可能是某个map task的运行情况。拿它与官方图的左半边比较，会发现很多不一致。官方图没有清楚地说明partition， sort与combiner到底作用在哪个阶段。我画了这张图，希望让大家清晰地了解从map数据输入到map端所有数据准备好的全过程。 </p>
<p>​        整个流程我分了四步。简单些可以这样说，每个map task都有一个内存缓冲区，存储着map的输出结果，当缓冲区快满的时候需要将缓冲区的数据以一个临时文件的方式存放到磁盘，当整个map task结束后再对磁盘中这个map task产生的所有临时文件做合并，生成最终的正式输出文件，然后等待reduce task来拉数据。 </p>
<p>​        当然这里的每一步都可能包含着多个步骤与细节，下面我对细节来一一说明： </p>
<ol>
<li><p>在map task执行时，它的输入数据来源于HDFS的block，当然在MapReduce概念中，map task只读取split。Split与block的对应关系可能是多对一，默认是一对一。在WordCount例子里，假设map的输入数据都是像“aaa”这样的字符串。 </p>
</li>
<li><p>在经过mapper的运行后，我们得知mapper的输出是这样一个key/value对： key是“aaa”， value是数值1。因为当前map端只做加1的操作，在reduce task里才去合并结果集。前面我们知道这个job有3个reduce task，到底当前的“aaa”应该交由哪个reduce去做呢，是需要现在决定的。 </p>
</li>
</ol>
<p>​        MapReduce提供Partitioner接口，它的作用就是根据key或value及reduce的数量来决定当前的这对输出数据最终应该交由哪个reduce task处理。默认对key hash后再以reduce task数量取模。默认的取模方式只是为了平均reduce的处理能力，如果用户自己对Partitioner有需求，可以订制并设置到job上。 </p>
<p>​        在我们的例子中，“aaa”经过Partitioner后返回0，也就是这对值应当交由第一个reducer来处理。接下来，需要将数据写入内存缓冲区中，缓冲区的作用是批量收集map结果，减少磁盘IO的影响。我们的key/value对以及Partition的结果都会被写入缓冲区。当然写入之前，key与value值都会被序列化成字节数组。 </p>
<p>​        整个内存缓冲区就是一个字节数组，它的字节索引及key/value存储结构我没有研究过。如果有朋友对它有研究，那么请大致描述下它的细节吧。 </p>
<ol>
<li>这个内存缓冲区是有大小限制的，默认是100MB。当map task的输出结果很多时，就可能会撑爆内存，所以需要在一定条件下将缓冲区中的数据临时写入磁盘，然后重新利用这块缓冲区。这个从内存往磁盘写数据的过程被称为Spill，中文可译为溢写，字面意思很直观。这个溢写是由单独线程来完成，不影响往缓冲区写map结果的线程。溢写线程启动时不应该阻止map的结果输出，所以整个缓冲区有个溢写的比例spill.percent。这个比例默认是0.8，也就是当缓冲区的数据已经达到阈值（buffer size <em> spill percent = 100MB </em> 0.8 = 80MB），溢写线程启动，锁定这80MB的内存，执行溢写过程。Map task的输出结果还可以往剩下的20MB内存中写，互不影响。 </li>
</ol>
<p>​        当溢写线程启动后，需要对这80MB空间内的key做排序(Sort)。排序是MapReduce模型默认的行为，这里的排序也是对序列化的字节做的排序。 </p>
<p>​        在这里我们可以想想，因为map task的输出是需要发送到不同的reduce端去，而内存缓冲区没有对将发送到相同reduce端的数据做合并，那么这种合并应该是体现是磁盘文件中的。从官方图上也可以看到写到磁盘中的溢写文件是对不同的reduce端的数值做过合并。所以溢写过程一个很重要的细节在于，如果有很多个key/value对需要发送到某个reduce端去，那么需要将这些key/value值拼接到一块，减少与partition相关的索引记录。 </p>
<p>​        在针对每个reduce端而合并数据时，有些数据可能像这样：“aaa”/1， “aaa”/1。对于WordCount例子，就是简单地统计单词出现的次数，如果在同一个map task的结果中有很多个像“aaa”一样出现多次的key，我们就应该把它们的值合并到一块，这个过程叫reduce也叫combine。但MapReduce的术语中，reduce只指reduce端执行从多个map task取数据做计算的过程。除reduce外，非正式地合并数据只能算做combine了。其实大家知道的，MapReduce中将Combiner等同于Reducer。 </p>
<p>​        如果client设置过Combiner，那么现在就是使用Combiner的时候了。将有相同key的key/value对的value加起来，减少溢写到磁盘的数据量。Combiner会优化MapReduce的中间结果，所以它在整个模型中会多次使用。那哪些场景才能使用Combiner呢？从这里分析，Combiner的输出是Reducer的输入，Combiner绝不能改变最终的计算结果。所以从我的想法来看，Combiner只应该用于那种Reduce的输入key/value与输出key/value类型完全一致，且不影响最终结果的场景。比如累加，最大值等。Combiner的使用一定得慎重，如果用好，它对job执行效率有帮助，反之会影响reduce的最终结果。 </p>
<ol>
<li>每次溢写会在磁盘上生成一个溢写文件，如果map的输出结果真的很大，有多次这样的溢写发生，磁盘上相应的就会有多个溢写文件存在。当map task真正完成时，内存缓冲区中的数据也全部溢写到磁盘中形成一个溢写文件。最终磁盘中会至少有一个这样的溢写文件存在(如果map的输出结果很少，当map执行完成时，只会产生一个溢写文件)，因为最终的文件只有一个，所以需要将这些溢写文件归并到一起，这个过程就叫做Merge。Merge是怎样的？如前面的例子，“aaa”从某个map task读取过来时值是5，从另外一个map 读取时值是8，因为它们有相同的key，所以得merge成group。什么是group。对于“aaa”就是像这样的：{“aaa”, [5, 8, 2, …]}，数组中的值就是从不同溢写文件中读取出来的，然后再把这些值加起来。请注意，因为merge是将多个溢写文件合并到一个文件，所以可能也有相同的key存在，在这个过程中如果client设置过Combiner，也会使用Combiner来合并相同的key。 </li>
</ol>
<p>​        至此，map端的所有工作都已结束，最终生成的这个文件也存放在TaskTracker够得着的某个本地目录内。每个reduce task不断地通过RPC从JobTracker那里获取map task是否完成的信息，如果reduce task得到通知，获知某台TaskTracker上的map task执行完成，Shuffle的后半段过程开始启动。 </p>
<p>​        简单地说，reduce task在执行之前的工作就是不断地拉取当前job里每个map task的最终结果，然后对从不同地方拉取过来的数据不断地做merge，也最终形成一个文件作为reduce task的输入文件。见下图：</p>
<p><img src="http://dl.iteye.com/upload/attachment/456527/608c7e08-896d-3697-a57e-a8ca60cf79ea.jpg" alt="img"></p>
<p>​        如map 端的细节图，Shuffle在reduce端的过程也能用图上标明的三点来概括。当前reduce copy数据的前提是它要从JobTracker获得有哪些map task已执行结束，这段过程不表，有兴趣的朋友可以关注下。Reducer真正运行之前，所有的时间都是在拉取数据，做merge，且不断重复地在做。如前面的方式一样，下面我也分段地描述reduce 端的Shuffle细节： </p>
<ol>
<li><p>Copy过程，简单地拉取数据。Reduce进程启动一些数据copy线程(Fetcher)，通过HTTP方式请求map task所在的TaskTracker获取map task的输出文件。因为map task早已结束，这些文件就归TaskTracker管理在本地磁盘中。 </p>
</li>
<li><p>Merge阶段。这里的merge如map端的merge动作，只是数组中存放的是不同map端copy来的数值。Copy过来的数据会先放入内存缓冲区中，这里的缓冲区大小要比map端的更为灵活，它基于JVM的heap size设置，因为Shuffle阶段Reducer不运行，所以应该把绝大部分的内存都给Shuffle用。这里需要强调的是，merge有三种形式：1)内存到内存  2)内存到磁盘  3)磁盘到磁盘。默认情况下第一种形式不启用，让人比较困惑，是吧。当内存中的数据量到达一定阈值，就启动内存到磁盘的merge。与map 端类似，这也是溢写的过程，这个过程中如果你设置有Combiner，也是会启用的，然后在磁盘中生成了众多的溢写文件。第二种merge方式一直在运行，直到没有map端的数据时才结束，然后启动第三种磁盘到磁盘的merge方式生成最终的那个文件。 </p>
</li>
<li><p>Reducer的输入文件。不断地merge后，最后会生成一个“最终文件”。为什么加引号？因为这个文件可能存在于磁盘上，也可能存在于内存中。对我们来说，当然希望它存放于内存中，直接作为Reducer的输入，但默认情况下，这个文件是存放于磁盘中的。至于怎样才能让这个文件出现在内存中，之后的<a href="http://langyu.iteye.com/blog/1341267" target="_blank" rel="noopener">性能优化篇</a>我再说。当Reducer的输入文件已定，整个Shuffle才最终结束。然后就是Reducer执行，把结果放到HDFS上。 </p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/19/数据倾斜的解决方法/" title="数据倾斜（转）" itemprop="url">数据倾斜（转）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-06-19T08:20:39.334Z" itemprop="datePublished"> 发表于 2018-06-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h3 id="数据倾斜介绍"><a href="#数据倾斜介绍" class="headerlink" title="数据倾斜介绍"></a>数据倾斜介绍</h3><p>简单的讲，数据倾斜就是我们在计算数据的时候，数据的分散度不够，导致大量的数据集中到了一台或者几台机器上计算，这些数据的计算速度远远低于平均计算速度，导致整个计算过程过慢。 </p>
<p>在做Shuffle阶段的优化过程中，遇到了数据倾斜的问题，造成了对一些情况下优化效果不明显。主要是因为在Job完成后的所得到的Counters是整个Job的总和，优化是基于这些Counters得出的平均值，而由于数据倾斜的原因造成map处理数据量的差异过大，使得这些平均值能代表的价值降低。Hive的执行是分阶段的，map处理数据量的差异取决于上一个stage的reduce输出，所以如何将数据均匀的分配到各个reduce中，就是解决数据倾斜的根本所在。规避错误来更好的运行比解决错误更高效。在查看了一些资料后，总结如下。</p>
<p>1数据倾斜的原因 </p>
<p>1.1操作：</p>
<table>
<thead>
<tr>
<th>关键词</th>
<th>情形</th>
<th>后果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Join</td>
<td>其中一个表较小，但是key集中</td>
<td>分发到某一个或几个Reduce   上的数据远       高于平均值</td>
</tr>
<tr>
<td></td>
<td>大表与大表，但是分桶的判断字段0值或空值过多</td>
<td>这些空值都由一个reduce     处理，灰常慢</td>
</tr>
<tr>
<td>group by</td>
<td>group by 维度过小，某值的数量过多</td>
<td>处理某值的reduce灰常耗时</td>
</tr>
<tr>
<td>Count Distinct</td>
<td>某特殊值过多</td>
<td>处理此特殊值的reduce耗时</td>
</tr>
</tbody>
</table>
<p>1.2原因：</p>
<p>1)、key分布不均匀</p>
<p>2)、业务数据本身的特性</p>
<p>3)、建表时考虑不周</p>
<p>4)、某些SQL语句本身就有数据倾斜</p>
<p>1.3表现：</p>
<p>任务进度长时间维持在99%（或100%），查看任务监控页面，发现只有少量（1个或几个）reduce子任务未完成。因为其处理的数据量和其他reduce差异过大。</p>
<p>单一reduce的记录数与平均记录数差异过大，通常可能达到3倍甚至更多。 最长时长远大于平均时长。</p>
<p>2数据倾斜的解决方案</p>
<p>2.1参数调节：</p>
<p>hive.map.aggr = true</p>
<p>Map 端部分聚合，相当于Combiner</p>
<p>hive.groupby.skewindata=true</p>
<p>有数据倾斜的时候进行负载均衡，当选项设定为 true，生成的查询计划会有两个 MR Job。第一个 MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key 有可能被分发到不同的 Reduce 中，从而达到负载均衡的目的；第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中（这个过程可以保证相同的 Group By Key 被分布到同一个 Reduce 中），最后完成最终的聚合操作。</p>
<p>2.2 SQL语句调节：</p>
<p>如何Join：</p>
<p>关于驱动表的选取，选用join key分布最均匀的表作为驱动表</p>
<p>做好列裁剪和filter操作，以达到两表做join的时候，数据量相对变小的效果。</p>
<p>大小表Join：</p>
<p>使用map join让小的维度表（1000条以下的记录条数） 先进内存。在map端完成reduce.</p>
<p>大表Join大表：</p>
<p>把空值的key变成一个字符串加上随机数，把倾斜的数据分到不同的reduce上，由于null值关联不上，处理后并不影响最终结果。</p>
<p>count distinct大量相同特殊值</p>
<p>count distinct时，将值为空的情况单独处理，如果是计算count distinct，可以不用处理，直接过滤，在最后结果中加1。如果还有其他计算，需要进行group by，可以先将值为空的记录单独处理，再和其他计算结果进行union。</p>
<p>group by维度过小：</p>
<p>采用sum() group by的方式来替换count(distinct)完成计算。</p>
<p>特殊情况特殊处理：</p>
<p>在业务逻辑优化效果的不大情况下，有些时候是可以将倾斜的数据单独拿出来处理。最后union回去。</p>
<p>3典型的业务场景</p>
<p>3.1空值产生的数据倾斜</p>
<p>场景：如日志中，常会有信息丢失的问题，比如日志中的 user_id，如果取其中的 user_id 和 用户表中的user_id 关联，会碰到数据倾斜的问题。</p>
<p>解决方法1： user_id为空的不参与关联</p>
<p>select * from log a</p>
<p>  join users b</p>
<p>  on a.user_id is not null</p>
<p>  and a.user_id = b.user_id</p>
<p>union all</p>
<p>select * from log a</p>
<p>  where a.user_id is null;</p>
<p>解决方法2 ：赋与空值分新的key值</p>
<p>select *</p>
<p>  from log a</p>
<p>  left outer join users b</p>
<p>  on case when a.user_id is null then concat(‘hive’,rand() ) else a.user_id end = b.user_id;</p>
<p>结论：方法2比方法1效率更好，不但io少了，而且作业数也少了。解决方法1中 log读取两次，jobs是2。解决方法2 job数是1 。这个优化适合无效 id (比如 -99 , ’’, null 等) 产生的倾斜问题。把空值的 key 变成一个字符串加上随机数，就能把倾斜的数据分到不同的reduce上 ,解决数据倾斜问题。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/05/31/奇异值分解(SVD)/" title="奇异值分解(SVD)" itemprop="url">奇异值分解(SVD)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-05-31T12:33:20.236Z" itemprop="datePublished"> 发表于 2018-05-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>奇异值分解（singular Value Decomposition），简称SVD，线性代数中矩阵分解的方法。假如有一个矩阵A，对它进行奇异值分解，可以得到三个矩阵：</p>
<p><img src="http://120.25.221.136/images/svd/svd.png" alt=""></p>
<p>分解矩阵的大小为下面：</p>
<p><img src="http://120.25.221.136/images/svd/fenjie.png" alt=""></p>
<p>在第二个矩阵中的矩阵特点是除了对角线不为0其余的元素都为0，并且对角线元素都是按照从大到小的排序。将上面中间矩阵只保存少数元素。</p>
<p><img src="http://120.25.221.136/images/svd/fenjie2.png" alt="">实际应用中，我们仅需保留着三个比较小的矩阵，就能表示A，不仅节省存储量，在计算的时候更是减少了计算量。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/05/31/python定义私有变量/" title="python定义私有变量" itemprop="url">python定义私有变量</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-05-31T12:09:32.565Z" itemprop="datePublished"> 发表于 2018-05-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ul>
<li><h2 id="python对象销毁-垃圾回收"><a href="#python对象销毁-垃圾回收" class="headerlink" title="python对象销毁(垃圾回收)"></a>python对象销毁(垃圾回收)</h2><p>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。</p>
<p>在 Python 内部记录着所有使用中的对象各有多少引用。</p>
<p>一个内部跟踪变量，称为一个引用计数器。</p>
<p>当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是”立即”的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 40      # 创建对象  &lt;40&gt;</span><br><span class="line">b = a       # 增加引用， &lt;40&gt; 的计数</span><br><span class="line">c = [b]     # 增加引用.  &lt;40&gt; 的计数</span><br><span class="line"></span><br><span class="line">del a       # 减少引用 &lt;40&gt; 的计数</span><br><span class="line">b = 100     # 减少引用 &lt;40&gt; 的计数</span><br><span class="line">c[0] = -1   # 减少引用 &lt;40&gt; 的计数</span><br></pre></td></tr></table></figure>
<p>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</p>
</li>
</ul>
<h3 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h3><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p>
<h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数</p>
<h3 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h3><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 <strong>self.__private_methods</strong></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustCounter</span>:</span></span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> self.__secretCount</span><br><span class="line"> </span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line"><span class="keyword">print</span> counter.publicCount</span><br><span class="line"><span class="keyword">print</span> counter.__secretCount  <span class="comment"># 报错，实例不能访问私有变量</span></span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/05/30/平方损失函数为什么用平方形式/" title="平方损失函数为什么用平方形式" itemprop="url">平方损失函数为什么用平方形式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-05-30T02:48:31.041Z" itemprop="datePublished"> 发表于 2018-05-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="平方损失函数形式"><a href="#平方损失函数形式" class="headerlink" title="平方损失函数形式"></a>平方损失函数形式</h4><p><strong>误差平方和(sse)：(The sum of squares due to error)</strong></p>
<p><img src="http://120.25.221.136/images/loss/sseloss.png" alt=""></p>
<p><strong>均方差（mse):(mean squared error)</strong></p>
<p><img src="http://120.25.221.136/images/loss/meanloss.png" alt=""></p>
<p>均方差与误差平方和形式上是等价的，两个公式前面的1/2是在求导时能够将2省略掉。</p>
<h3 id="平方形式的原因"><a href="#平方形式的原因" class="headerlink" title="平方形式的原因"></a>平方形式的原因</h3><ul>
<li><p>损失函数的值为正数</p>
<p>在计算损失时，会出现正数和负数，为了防止损失被抵消，所以全部都转变为正数累加。</p>
</li>
<li><p>能够惩罚大误差</p>
<p>惩罚大误差更快寻找误差较小的最优权重值。</p>
</li>
<li><p>求导方便</p>
<p>虽然4次方，6次方也可以避免损失之下损失值相互抵消但惩罚过大，造成欠拟合，且求导之后扔是多次函数。绝对值求导为分段函数，需要分段求导。</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/05/28/动态规划解决01背包问题/" title="动态规划解决01背包问题（转）" itemprop="url">动态规划解决01背包问题（转）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="PengYuan" target="_blank" itemprop="author">PengYuan</a>
		
  <p class="article-time">
    <time datetime="2018-05-28T02:30:21.853Z" itemprop="datePublished"> 发表于 2018-05-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>0-1 背包问题：给定 n 种物品和一个容量为 C 的背包，物品 i 的重量是 wi，其价值为 vi 。</p>
<p>问：应该如何选择装入背包的物品，使得装入背包中的物品的总价值最大？</p>
<p>对于每个物体，要么放入背包要么不放进背包，不存在将物体的一部分放入背包。</p>
<p><strong>三、动态规划的原理及过程：</strong></p>
<p>　　eg：number＝4，capacity＝8</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>i</strong></th>
<th style="text-align:center"><strong>1</strong></th>
<th style="text-align:center"><strong>2</strong></th>
<th style="text-align:center"><strong>3</strong></th>
<th style="text-align:center"><strong>4</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>w(体积)</strong></td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center"><strong>v(价值)</strong></td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p><strong>1**</strong>、<strong>**原理</strong></p>
<p>　　动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。</p>
<p><strong>2**</strong>、<strong>**过程</strong></p>
<p>　　a) 把背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选），Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积（重量）；</p>
<p>　　b) 建立模型，即求max(V1X1+V2X2+…+VnXn)；</p>
<p>　　c) 约束条件，W1X1+W2X2+…+WnXn&lt;capacity；</p>
<p>　　d) 定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值；</p>
<p>　　e) 最优性原理是动态规划的基础，最优性原理是指“多阶段决策过程的最优决策序列具有这样的性质：不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言，其后各阶段的决策序列必须构成最优策略”。判断该问题是否满足最优性原理，采用反证法证明：</p>
<p>　　　　假设(X1，X2，…，Xn)是01背包问题的最优解，则有(X2，X3，…，Xn)是其子问题的最优解，</p>
<p>　　　　假设(Y2，Y3，…，Yn)是上述问题的子问题最优解，则理应有(V2Y2+V3Y3+…+VnYn)+V1X1 &gt; (V2X2+V3X3+…+VnXn)+V1X1；</p>
<p>　　　　而(V2X2+V3X3+…+VnXn)+V1X1=(V1X1+V2X2+…+VnXn)，则有(V2Y2+V3Y3+…+VnYn)+V1X1 &gt; (V1X1+V2X2+…+VnXn)；</p>
<p>　　　　该式子说明(X1，Y2，Y3，…，Yn)才是该01背包问题的最优解，这与最开始的假设(X1，X2，…，Xn)是01背包问题的最优解相矛盾，故01背包问题满足最优性原理；</p>
<p>　　f) 寻找递推关系式，面对当前商品有两种可能性：</p>
<p>　　　　第一，包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；</p>
<p>　　　　第二，还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛ V(i-1,j)，V(i-1,j-w(i))+v(i) ｝</p>
<p>　　　　　　　其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)但价值增加了v(i)；</p>
<p>　　　　由此可以得出递推关系式：</p>
<p>　　　　1) <strong>j&lt;w(i)</strong>      <strong>V(i,j)=V(i-1,j)</strong></p>
<p>　　　　2) <strong>j&gt;=w(i)</strong>     <strong>V(i,j)=max**</strong>｛<strong> </strong>V(i-1,j)<strong><strong>，</strong></strong>V(i-1,j-w(i))+v(i)<strong> </strong>｝**</p>
<p>　　g) 填表，首先初始化边界条件，V(0,j)=V(i,0)=0；</p>
<p> <img src="https://images2015.cnblogs.com/blog/1065397/201703/1065397-20170328165007186-1423294617.png" alt="img"></p>
<p>　　h) 然后一行一行的填表，</p>
<p>　　　　1) 如，i=1，j=1，w(1)=2，v(1)=3，有j&lt;w(1)，故V(1,1)=V(1-1,1)=0；</p>
<p>　　　　2) 又如i=1，j=2，w(1)=2，v(1)=3，有j=w(1),故V(1,2)=max｛ V(1-1,2)，V(1-1,2-w(1))+v(1) ｝=max｛0，0+3｝=3；</p>
<p>　　　　3) 如此下去，填到最后一个，i=4，j=8，w(4)=5，v(4)=6，有j&gt;w(4)，故V(4,8)=max｛ V(4-1,8)，V(4-1,8-w(4))+v(4) ｝=max｛9，4+6｝=10；所以填完表如下图：</p>
<p> <img src="https://images2015.cnblogs.com/blog/1065397/201703/1065397-20170328165055498-1241953671.png" alt="img"></p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">FindMax</span><span class="params">()</span><span class="comment">//动态规划</span></span></span><br><span class="line"><span class="function"> 2 </span>&#123;</span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> i,j;</span><br><span class="line"> <span class="number">4</span>     <span class="comment">//填表</span></span><br><span class="line"> <span class="number">5</span>     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=number;i++)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=capacity;j++)</span><br><span class="line"> <span class="number">8</span>         &#123;</span><br><span class="line"> <span class="number">9</span>             <span class="keyword">if</span>(j&lt;w[i])<span class="comment">//包装不进</span></span><br><span class="line"><span class="number">10</span>             &#123;</span><br><span class="line"><span class="number">11</span>                 V[i][j]=V[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="number">12</span>             &#125;</span><br><span class="line"><span class="number">13</span>             <span class="keyword">else</span><span class="comment">//能装</span></span><br><span class="line"><span class="number">14</span>             &#123;</span><br><span class="line"><span class="number">15</span>                 <span class="keyword">if</span>(V[i<span class="number">-1</span>][j]&gt;V[i<span class="number">-1</span>][j-w[i]]+v[i])<span class="comment">//不装价值大</span></span><br><span class="line"><span class="number">16</span>                 &#123;</span><br><span class="line"><span class="number">17</span>                     V[i][j]=V[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="number">18</span>                 &#125;</span><br><span class="line"><span class="number">19</span>                 <span class="keyword">else</span><span class="comment">//前i-1个物品的最优解与第i个物品的价值之和更大</span></span><br><span class="line"><span class="number">20</span>                 &#123;</span><br><span class="line"><span class="number">21</span>                     V[i][j]=V[i<span class="number">-1</span>][j-w[i]]+v[i];</span><br><span class="line"><span class="number">22</span>                 &#125;</span><br><span class="line"><span class="number">23</span>             &#125;</span><br><span class="line"><span class="number">24</span>         &#125;</span><br><span class="line"><span class="number">25</span>     &#125;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>　　i) 表格填完，最优解即是V(number,capacity)=V(4,8)=10，但还不知道解由哪些商品组成，故要根据最优解回溯找出解的组成，根据填表的原理可以有如下的寻解方式：</p>
<p>　　　　1) V(i,j)=V(i-1,j)时，说明没有选择第i 个商品，则回到V(i-1,j)；</p>
<p>　　　　2) V(i,j)=V(i-1,j-w(i))+v(i)实时，说明装了第i个商品，该商品是最优解组成的一部分，随后我们得回到装该商品之前，即回到V(i-1,j-w(i))；</p>
<p>　　　　3) 一直遍历到i＝0结束为止，所有解的组成都会找到。</p>
<p>　　j) 如上例子，</p>
<p>　　　　1) 最优解为V(4,8)=10，而V(4,8)!=V(3,8)却有V(4,8)=V(3,8-w(4))+v(4)=V(3,3)+6=4+6=10，所以第4件商品被选中，并且回到V(3,8-w(4))=V(3,3)；</p>
<p>　　　　2) 有V(3,3)=V(2,3)=4，所以第3件商品没被选择，回到V(2,3)；</p>
<p>　　　　3) 而V(2,3)!=V(1,3)却有V(2,3)=V(1,3-w(2))+v(2)=V(1,0)+4=0+4=4，所以第2件商品被选中，并且回到V(1,3-w(2))=V(1,0)；</p>
<p>　　　　4) 有V(1,0)=V(0,0)=0，所以第1件商品没被选择；</p>
<p> <img src="https://images2015.cnblogs.com/blog/1065397/201703/1065397-20170328165219092-1883633849.png" alt="img"></p>
<p>　　k) 到此，01背包问题已经解决，利用动态规划解决此问题的效率即是填写此张表的效率，所以动态规划的时间效率为O(number<em>capacity)=O(n</em>c)，由于用到二维数组存储子问题的解，所以动态规划的空间效率为O(n*c)；</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">FindWhat</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span><span class="comment">//寻找解的组成方式</span></span></span><br><span class="line"><span class="function"> 2 </span>&#123;</span><br><span class="line"> <span class="number">3</span>     <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line"> <span class="number">4</span>     &#123;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">if</span>(V[i][j]==V[i<span class="number">-1</span>][j])<span class="comment">//相等说明没装</span></span><br><span class="line"> <span class="number">6</span>         &#123;</span><br><span class="line"> <span class="number">7</span>             item[i]=<span class="number">0</span>;<span class="comment">//全局变量，标记未被选中</span></span><br><span class="line"> <span class="number">8</span>             FindWhat(i<span class="number">-1</span>,j);</span><br><span class="line"> <span class="number">9</span>         &#125;</span><br><span class="line"><span class="number">10</span>         <span class="keyword">else</span> <span class="keyword">if</span>( j-w[i]&gt;=<span class="number">0</span> &amp;&amp; V[i][j]==V[i<span class="number">-1</span>][j-w[i]]+v[i] )</span><br><span class="line"><span class="number">11</span>         &#123;</span><br><span class="line"><span class="number">12</span>             item[i]=<span class="number">1</span>;<span class="comment">//标记已被选中</span></span><br><span class="line"><span class="number">13</span>             FindWhat(i<span class="number">-1</span>,j-w[i]);<span class="comment">//回到装包之前的位置</span></span><br><span class="line"><span class="number">14</span>         &#125;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>3、空间优化</strong></p>
<p>　　l) 空间优化，每一次V(i)(j)改变的值只与V(i-1)(x) {x:1…j}有关，V(i-1)(x)是前一次i循环保存下来的值；</p>
<p>　　因此，可以将V缩减成一维数组，从而达到优化空间的目的，状态转移方程转换为 <strong>B(j)= max{B(j), B(j-w(i))+v(i)}</strong>；</p>
<p>　　并且，状态转移方程，每一次推导V(i)(j)是通过V(i-1)(j-w(i))来推导的，所以一维数组中j的扫描顺序应该从大到小(capacity到0)，否者前一次循环保存下来的值将会被修改，从而造成错误。</p>
<p> <img src="https://images2015.cnblogs.com/blog/1065397/201703/1065397-20170328165423936-1589228819.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/1065397/201703/1065397-20170328165439139-1416618143.png" alt="img"></p>
<p>　　m) 同样以上述例子中i=3时来说明，有:</p>
<p>　　　　1) i=3，j=8，w(3)=4，v(3)=5，有j&gt;w(3)，则B(8)=max｛B(8)，B(8-w(3))+v(3)｝=max｛B(8)，B(4)+5｝=max｛7，4+5｝=9；</p>
<p>　　　　2) j- -即j=7，有j&gt;w(3)，则B(7)=max｛B(7)，B(7-w(3))+v(3)｝=max｛B(7)，B(3)+5｝=max｛7，4+5｝=9；</p>
<p>　　　　3) j- -即j=6，有j&gt;w(3)，则B(6)=max｛B(6)，B(6-w(3))+v(3)｝=max｛B(6)，B(2)+5｝=max｛7，3+5｝=8；</p>
<p>　　　　4) j- -即j=5，有j&gt;w(3)，则B(5)=max｛B(5)，B(5-w(3))+v(3)｝=max｛B(5)，B(1)+5｝=max｛7，0+5｝=7；</p>
<p>　　　　5) j- -即j=4，有j＝w(3)，则B(4)=max｛B(4)，B(4-w(3))+v(3)｝=max｛B(4)，B(0)+5｝=max｛4，0+5｝=5；</p>
<p>　　　　6) j- -即j=3，有j&lt;w(3)，继续访问数组会出现越界，所以本轮操作停止，B(0)到B(3)的值保留上轮循环（i=2时）的值不变，进入下一轮循环i++；</p>
<p> <img src="https://images2015.cnblogs.com/blog/1065397/201703/1065397-20170328165558420-477181327.png" alt="img"></p>
<p>　　如果j不逆序而采用正序j=0…capacity，如上图所示，当j=8时应该有B(8)=B(8-w(3))+v(3)=B(4)+5，然而此时的B(4)已经在j=4的时候被修改过了，原来的B(4)=4，现在B(4)=5，所以计算得出B(8)=5+5=10，显然这于正确答案不符合；所以该一维数组后面的值需要前面的值进行运算再改动，如果正序便利，则前面的值将有可能被修改掉从而造成后面数据的错误；相反如果逆序遍历，先修改后面的数据再修改前面的数据，此种情况就不会出错了；</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">FindMaxBetter</span><span class="params">()</span><span class="comment">//优化空间后的动态规划</span></span></span><br><span class="line"><span class="function"> 2 </span>&#123;</span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> i,j;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=number;i++)</span><br><span class="line"> <span class="number">5</span>     &#123;</span><br><span class="line"> <span class="number">6</span>         <span class="keyword">for</span>(j=capacity;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line"> <span class="number">7</span>         &#123;</span><br><span class="line"> <span class="number">8</span>             <span class="keyword">if</span>(B[j]&lt;=B[j-w[i]]+v[i] &amp;&amp; j-w[i]&gt;=<span class="number">0</span> )<span class="comment">//二维变一维</span></span><br><span class="line"> <span class="number">9</span>             &#123;</span><br><span class="line"><span class="number">10</span>                 B[j]=B[j-w[i]]+v[i];</span><br><span class="line"><span class="number">11</span>             &#125;</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span> &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>　　n) 然而不足的是，虽然优化了动态规划的空间，但是该方法不能找到最优解的解组成，因为动态规划寻早解组成一定得在确定了最优解的前提下再往回找解的构成，而优化后的动态规划只用了一维数组，之前的数据已经被覆盖掉，所以没办法寻找，所以两种方法各有其优点。</p>
<p><strong>四、蛮力法检验：</strong></p>
<p>　　1) 蛮力法是解决01背包问题最简单最容易的方法，但是效率很低</p>
<p>　　2) (X1，X2，…，Xn)其中Xi＝0或1表示第i件商品选或不选，共有n(n-1)/2种可能；</p>
<p>　　3) 最简单的方式就是把所有拿商品的方式都列出来，最后再做判断此方法是否满足装包条件，并且通过比较和记录找出最优解和解组成（如果满足则记录此时的价值和装的方式，当下一次的装法优于这次，则更新记录，如此下去到最后便会找到最优解，同时解组成也找到）；</p>
<p>　　4) n件商品，共有n(n-1)/2种可能，故蛮力法的效率是指数级别的，可见效率很低;</p>
<p>　　5) 蛮力法效率低不建议采取，但可以用于检验小规模的动态规划解背包问题的正确性和可行性，如下图输出可见，解01背包问题用动态规划是可行的：</p>
<p><img src="https://images2015.cnblogs.com/blog/1065397/201703/1065397-20170328170108279-1164054042.png" alt="img"></p>
<p><strong>五、总结：</strong></p>
<p>　　对于01背包问题，用蛮力法与用动态规划解决得到的最优解和解组成是一致的，所以动态规划解决此类问题是可行的。动态规划效率为线性，蛮力法效率为指数型，结合以上内容和理论知识可以得出，解决此问题用动态规划比用蛮力法适合得多。对于动态规划不足的是空间开销大，数据的存储得用到二维数组；好的是，当前问题的解只与上一层的子问题的解相关，所以，可以把动态规划的空间进行优化，使得空间效率从O(n*c)转化为O(c)，遗憾的是，虽然优化了空间，但优化后只能求出最优解，解组成的探索方式在该方法运行的时候已经被破坏掉；总之动态规划和优化后的动态规划各有优缺点，可以根据实际问题的需求选择不同的方式。</p>
<p><strong>六、引申：</strong></p>
<p>　　动态规划可以解决哪些类型的问题？</p>
<p>　　待解决的原问题较难，但此问题可以被不断拆分成一个个小问题，而小问题的解是非常容易获得的；如果单单只是利用递归的方法来解决原问题，那么采用的是分治法的思想，动态规划具有记忆性，将子问题的解都记录下来，以免在递归的过程中重复计算，从而减少了计算量。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="https://github.com/pengyuanqiuqiu" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>



  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.nowcoder.com/" target="_blank" title="牛客网">牛客网</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.acmcoder.com/index" target="_blank" title="赛码网">赛码网</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="http://www.163.com/rss/" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="400" class="share_self"  frameborder="0" scrolling="no" src="https://widget.weibo.com/weiboshow/index.php?language=&width=0&height=400&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=2871001534&verifier=2889e96f&colors=d6f3f7,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m jianyu. <br/>
			Let&#39;s go!</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2871001534" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/pengyuanqiuqiu" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/peng-yuan-19-57?utm_source=qq&amp;utm_medium=social" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:987219258@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by © 2018 
		
		<a href="https://pengyuanqiuqiu.github.io/" target="_blank" title="PengYuan">PengYuan</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
